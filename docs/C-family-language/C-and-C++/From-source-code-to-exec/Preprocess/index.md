# Preprocessor 

## What is preprocessor?

参见: 

wikipedia [Preprocessor](https://en.wikipedia.org/wiki/Preprocessor)



microsoft [C/C++ preprocessor reference](C/C++ preprocessor reference)



[gcc The C Preprocessor](https://gcc.gnu.org/onlinedocs/cpp/)





## cppreference Preprocessor

The preprocessor is executed at [translation phase 4](https://en.cppreference.com/w/cpp/language/translation_phases), before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.

### Directives and Capabilities

preprocessing instruction

> NOTE: 预编译指令，它们都是以`#`打头的，下面是对它们的分类

| Capabilities                                                 | Directive                                                    |      |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| [Conditional inclusion](https://en.cppreference.com/w/cpp/preprocessor/conditional) | `#if`, `#ifdef`, `#ifndef`, <br/>`#else`, `#elif` and <br/>`#endif` |      |
| [Replacing text macros](https://en.cppreference.com/w/cpp/preprocessor/replace) | 1) `#define` and `#undef` <br/>2) `#` and `##                |      |
| [Source file inclusion](https://en.cppreference.com/w/cpp/preprocessor/include) | `include`, <br/>`__has_include`(since C++17)                 |      |
| [Error directive](https://en.cppreference.com/w/cpp/preprocessor/error) | `error`,                                                     |      |
| [Implementation defined behavior control](https://en.cppreference.com/w/cpp/preprocessor/impl) | `pragma`, <br/>`_Pragma`(since C++11)                        |      |
| [Filename and line information](https://en.cppreference.com/w/cpp/preprocessor/line) | `line`,                                                      |      |

[[1\]](https://en.cppreference.com/w/cpp/preprocessor#cite_note-1)



## cppreference [Replacing text macros](https://en.cppreference.com/w/cpp/preprocessor/replace)

### `#` and `##` operators



### Predefined macros

#### `__cplusplus`

denotes the version of C++ standard that is being used, expands to value :

199711L(until C++11), 

201103L(C++11), 

201402L(C++14), 

201703L(C++17), or 

202002L(C++20) (macro constant)

> NOTE: 

#### `__STDC_HOSTED__`(C++11)

expands to the integer constant 1 if the implementation is hosted (runs under an OS), 0 if freestanding (runs without an OS) (macro constant)

#### `__FILE__`  and`__LINE__`

expands to the name of the current file, as a character string literal, can be changed by the [`#line`](https://en.cppreference.com/w/cpp/preprocessor/line) directive (macro constant)

expands to the source file line number, an integer constant, can be changed by the [`#line`](https://en.cppreference.com/w/cpp/preprocessor/line) directive (macro constant)

#### `__DATE__` and `__TIME__`

expands to the date of translation, a character string literal of the form "Mmm dd yyyy". The first character of "dd" is a space if the day of the month is less than 10. The name of the month is as if generated by [std::asctime](http://en.cppreference.com/w/cpp/chrono/c/asctime)() (macro constant)

expands to the time of translation, a character string literal of the form "hh:mm:ss" (macro constant)



#### `__STDCPP_DEFAULT_NEW_ALIGNMENT__`(C++17)

expands to an [std::size_t](https://en.cppreference.com/w/cpp/types/size_t) literal whose value is the alignment guaranteed by a call to alignment-unaware [operator new](https://en.cppreference.com/w/cpp/memory/new/operator_new) (larger alignments will be passed to alignment-aware overload, such as [operator new](http://en.cppreference.com/w/cpp/memory/new/operator_new)([std::size_t](http://en.cppreference.com/w/cpp/types/size_t), [std::align_val_t](http://en.cppreference.com/w/cpp/memory/new/align_val_t)) (macro constant)



### 补充

​	

#### `__pretty_function__`

stackoverflow [What's the difference between __PRETTY_FUNCTION__, __FUNCTION__, __func__?](https://stackoverflow.com/questions/4384765/whats-the-difference-between-pretty-function-function-func)



## cppreference [Implementation defined behavior control](https://en.cppreference.com/w/cpp/preprocessor/impl)

> NOTE: 下面是一些我遇到的`pragma`:
>
> - `#pragma once`
> - `#pragma region ***`  `#pragma endregion ***`
> - `#pragma pack`



## include guard and `#pragma once`



### wikipedia [include guard](https://en.wikipedia.org/wiki/Include_guard)

In the [C](https://en.wikipedia.org/wiki/C_(programming_language)) and [C++](https://en.wikipedia.org/wiki/C%2B%2B) programming languages, an **#include guard**, sometimes called a **macro guard**, **header guard** or **file guard**, is a particular construct used to avoid the problem of *double inclusion* when dealing with the [include directive](https://en.wikipedia.org/wiki/Include_directive).

The addition of `#include` guards to a header file is one way to make that file [idempotent](https://en.wikipedia.org/wiki/Idempotent). Another construct to combat(反对) *double inclusion* is [#pragma once](https://en.wikipedia.org/wiki/Pragma_once), which is non-standard but nearly universally supported among C and C++ [compilers](https://en.wikipedia.org/wiki/List_of_compilers).



### wikipedia [pragma once](https://en.wikipedia.org/wiki/Pragma_once)

In the [C](https://en.wikipedia.org/wiki/C_(programming_language)) and [C++](https://en.wikipedia.org/wiki/C%2B%2B) programming languages, `**pragma once**` is a non-standard but widely supported [preprocessor directive](https://en.wikipedia.org/wiki/C_preprocessor) designed to cause the current [source file](https://en.wikipedia.org/wiki/Source_file) to be included only once in a single compilation.[[1\]](https://en.wikipedia.org/wiki/Pragma_once#cite_note-1) Thus, `#pragma once` serves the same purpose as [include guards](https://en.wikipedia.org/wiki/Include_guard), but with several advantages, including: less code, avoidance of name clashes, and sometimes improvement in compilation speed.[[2\]](https://en.wikipedia.org/wiki/Pragma_once#cite_note-2) On the other hand, `#pragma once` is not necessarily available in all compilers and its implementation is tricky and might not always be reliable.

### stackoverflow [Is #pragma once a safe include guard?](https://stackoverflow.com/questions/787533/is-pragma-once-a-safe-include-guard)

```C++
#pragma once
#ifndef HEADER_H
#define HEADER_H

...

#endif // HEADER_H
```

[A](https://stackoverflow.com/a/1946730)

`#pragma once` does have one drawback (other than being non-standard) and that is if you have the same file in different locations (we have this because our build system copies files around) then the compiler will think these are different files.

[A](https://stackoverflow.com/a/787539)

Using `#pragma once` should work on any modern compiler, but I don't see any reason not to use a standard `#ifndef` include guard. It works just fine. The one caveat is that GCC didn't support `#pragma once` before [version 3.4](http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11569).

I also found that, at least on GCC, [it recognizes the standard `#ifndef` include guard and optimizes it](http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC8), so it shouldn't be much slower than `#pragma once`.