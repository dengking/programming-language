# Templates

template是c++的关键特性。

## 维基百科[Template (C++)](https://en.wikipedia.org/wiki/Template_(C%2B%2B))

### [Technical overview](https://en.wikipedia.org/wiki/Template_(C%2B%2B)#Technical_overview)

There are three kinds of templates: *function templates*, *class templates* and, since [C++14](https://en.wikipedia.org/wiki/C%2B%2B14), *variable templates*. Since [C++11](https://en.wikipedia.org/wiki/C%2B%2B11), templates may be either [variadic](https://en.wikipedia.org/wiki/Variadic_template) or non-variadic; in earlier versions of C++ they are always non-variadic.

> NOTE: 两种分类方式
>
> 分类方式一：
>
> *function templates*
>
> *class templates* 
>
> *variable templates* （since [C++14](https://en.wikipedia.org/wiki/C%2B%2B14)）
>
> 分类方式二：
>
> [variadic](https://en.wikipedia.org/wiki/Variadic_template)
>
> non-variadic
>
> 

## cppreference [Templates](https://en.cppreference.com/w/cpp/language/templates)

Templates are parameterized by one or more [template parameters](https://en.cppreference.com/w/cpp/language/template_parameters), of three kinds: type template parameters, non-type template parameters, and template template parameters.

> NOTE: 虽然上述列举了三种template parameter，但是，可以简单的认为c++模板主要允许programmer参数化：
>
> - type，type template parameter（duck type，参见`Theory\Programming-paradigm\Generic-programming\Templates-and-Duck-Typing\Templates-and-Duck-Typing.md`）
> - value，non-type template parameter
>
> 至于template template parameter，它其实可以归入上述两者之一



When **template arguments** are provided, or, for [function](https://en.cppreference.com/w/cpp/language/function_template#Template_argument_deduction) and [class](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction) (since C++17) templates only, deduced, they are substituted for the **template parameters** to obtain a *specialization* of the template, that is, a specific type or a specific function lvalue. 

> NOTE: specification的结果是：a specific type、a specific function lvalue。

Specializations may also be provided explicitly: 

[full specializations](https://en.cppreference.com/w/cpp/language/template_specialization) are allowed for class, variable (since C++14) and function templates.

[partial specializations](https://en.cppreference.com/w/cpp/language/partial_specialization) are only allowed for class templates and variable templates (since C++14).

> NOTE: specialization的分类：
>
> explicit specialization：
>
> - full specialization
> - partial specialization
>
> implicit specialization：deduced。



> NOTE: function template不支持partial specialization，但是通过`enable_if` + SFINAE + trait技术，也可以实现类似于partial specialization的效果，这通常被称为function template SFINAE，在`C-family-language\C++\Idiom\Template-metaprogramming\SFINAE-trait-enable-if\SFINAE\Function-template-SFINAE.md`中对它进行了介绍。

When a **class template specialization** is referenced in context that requires a complete object type, or when a **function template specialization** is referenced in context that requires a function definition to exist, the template is *instantiated* (the code for it is actually compiled), unless the template was already explicitly specialized or explicitly instantiated. Instantiation of a class template doesn't instantiate any of its member functions unless they are also used. At link time, **identical instantiations** generated by different translation units are merged.

> ## Specialization and instantiation of template
>
> specialization->instantiation，即先specialization，然后instantiation，instantiation发生在实际使用specialization的时候。必须使用specialization of template，才能够instantiation 一个template。
>
> specialization是对一种特殊情况的特殊实现，specialization相当于OOP中的inheritance；
>
> instantiation 是compiler真正的实现代码。



> ## Lazyness of template instantiation
>
> 上面这段话中的“Instantiation of a class template doesn't instantiate any of its member functions unless they are also used.”其实已经揭示了lazyness of template instantiation。正如在process中有copy-on-write，template instantiation是instantiation-on-use。借助于Lazyness of template instantiation，我们可以实现conditional compiling，这在`C-family-language\C++\Idiom\Template-metaprogramming\SFINAE-trait-enable-if\SFINAE.md#SFINAE and conditional compiling`中进行了详细介绍。
>
> Lazyness of template instantiation让我联想到了维基百科[Type system#Static type checking](https://en.wikipedia.org/wiki/Type_system#Static_type_checking)中关于`if <complex test> then <do something> else <signal that there is a type error>`的讨论，显然，它是一种run-time lazy；Lazyness of template instantiation是一种compile-time lazy。

> NOTE: 不同的translation unit，可能instantiate了同一个template，显然， 它们就包含了相同的instantiation，也就是相同的definition，对于这种情况，一般情况下，compiler是会报multiple definition的，但是对于template，它是会进行特殊处理的。

The definition of a template must be visible at the point of implicit instantiation, which is why template libraries typically provide all template definitions in the headers (e.g. [most boost libraries are header-only](http://www.boost.org/doc/libs/release/more/getting_started/unix-variants.html#header-only-libraries))

> NOTE: 什么叫做implicit instantiation