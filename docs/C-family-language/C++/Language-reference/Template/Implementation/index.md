# 关于本章

编译器如何编译template？这个问题其实是在探讨编译器是如何实现模板的，本章對這個問題進行展開，描述C++ template的實現。理解template的實現，對於掌握、運用template至關重要。

遺憾的是，在cppreference中，并沒有對此的專門描述，我們只能夠搜集一些素材自己進行總結。这个问题也可以通过如下的方式进行Google：

- Google c++ template mechanism
- Google c++ compiler template

## Template is a kind of static polymorphism

Template is a kind of static polymorphism，对于这个结论，我们需要从下面两个方面进行深入的分析：

1. 从“polymorphism”：既然template是一种polymorphism，那么它的实现思路可以使用在`C++\Guide\Implementation-of-polymorphism`中描述的思想
2. 从“static”：既然是static，那么它就发生于compile-time，那么“The definition of a template must be visible at the point of implicit instantiation, which is why template libraries typically provide all template definitions in the headers”（截取自cppreference [Templates](https://en.cppreference.com/w/cpp/language/templates)）

## Specialization and instantiation of template

本节描述Specialization and instantiation of template，下面是涉及这个主题的素材。

### 素材: cppreference [Templates](https://en.cppreference.com/w/cpp/language/templates)

When **template arguments** are provided, or, for [function](https://en.cppreference.com/w/cpp/language/function_template#Template_argument_deduction) and [class](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction) (since C++17) templates only, deduced, they are substituted for the **template parameters** to obtain a *specialization* of the template, that is, a specific type or a specific function lvalue. 

> NOTE: specification的结果是：a specific type、a specific function lvalue。

Specializations may also be provided explicitly: 

[full specializations](https://en.cppreference.com/w/cpp/language/template_specialization) are allowed for class, variable (since C++14) and function templates.

[partial specializations](https://en.cppreference.com/w/cpp/language/partial_specialization) are only allowed for class templates and variable templates (since C++14).

> NOTE: specialization的分类：
>
> explicit specialization：
>
> - full specialization
> - partial specialization
>
> implicit specialization：deduced。



> NOTE: function template不支持partial specialization，但是通过`enable_if` + SFINAE + trait技术，也可以实现类似于partial specialization的效果，这通常被称为function template SFINAE，在`C-family-language\C++\Idiom\Template-metaprogramming\SFINAE-trait-enable-if\SFINAE\Function-template-SFINAE.md`中对它进行了介绍。

When a **class template specialization** is referenced in context that requires a complete object type, or when a **function template specialization** is referenced in context that requires a function definition to exist, the template is *instantiated* (the code for it is actually compiled), unless the template was already explicitly specialized or explicitly instantiated. Instantiation of a class template doesn't instantiate any of its member functions unless they are also used. At link time, **identical instantiations** generated by different translation units are merged.

> # Specialization and instantiation of template
>
> specialization->instantiation，即先specialization，然后instantiation，instantiation发生在实际使用specialization的时候。必须使用specialization of template，才能够instantiation 一个template。
>
> specialization是对一种特殊情况的特殊实现，specialization相当于OOP中的inheritance；
>
> instantiation 是compiler真正的实现代码。
>
> 关于此的一个典型的例子就是[Curiously recurring template pattern](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism)：
>
> ```c++
> #include <iostream>
> 
> template<class T>
> struct Base
> {
> 	void interface()
> 	{
> 		// ...
> 		static_cast<T*>(this)->implementation();
> 		// ...
> 	}
> 
> 	static void static_func()
> 	{
> 		// ...
> 		T::static_sub_func();
> 		// ...
> 	}
> };
> 
> struct Derived: Base<Derived>
> {
> 	void implementation()
> 	{
> 		std::cout << __PRETTY_FUNCTION__ << std::endl;
> 	}
> 	static void static_sub_func()
> 	{
> 		std::cout << __PRETTY_FUNCTION__ << std::endl;
> 	}
> };
> int main()
> {
> 	Derived d;
> 
> 	d.interface();
> 	d.static_sub_func();
> }
> // g++ test.cpp
> #include <iostream>
> 
> template<class T>
> struct Base
> {
> 	void interface()
> 	{
> 		// ...
> 		static_cast<T*>(this)->implementation();
> 		// ...
> 	}
> 
> 	static void static_func()
> 	{
> 		// ...
> 		T::static_sub_func();
> 		// ...
> 	}
> };
> 
> struct Derived: Base<Derived>
> {
> 	void implementation()
> 	{
> 		std::cout << __PRETTY_FUNCTION__ << std::endl;
> 	}
> 	static void static_sub_func()
> 	{
> 		std::cout << __PRETTY_FUNCTION__ << std::endl;
> 	}
> };
> int main()
> {
> 	Derived d;
> 
> 	d.interface();
> 	d.static_sub_func();
> }
> // g++ test.cpp
> 
> ```
>
> > In the above example, note in particular that the function `Base<Derived>::interface()`, though *declared* before the existence of the `struct Derived` is known by the compiler (i.e., before `Derived` is declared), is not actually *instantiated* by the compiler until it is actually *called* by some later code which occurs *after* the declaration of `Derived` (not shown in the above example), so that at the time the function "`implementation`" is instantiated, the declaration of `Derived::implementation()` is known.



> # Lazyness of template instantiation
>
> 上面这段话中的“Instantiation of a class template doesn't instantiate any of its member functions unless they are also used.”其实已经揭示了lazyness of template instantiation。正如在process中有copy-on-write，template instantiation是instantiation-on-use。借助于Lazyness of template instantiation，我们可以实现conditional compiling，这在`C-family-language\C++\Idiom\Template-metaprogramming\SFINAE-trait-enable-if\SFINAE.md#SFINAE and conditional compiling`中进行了详细介绍。
>
> Lazyness of template instantiation让我联想到了维基百科[Type system#Static type checking](https://en.wikipedia.org/wiki/Type_system#Static_type_checking)中关于`if <complex test> then <do something> else <signal that there is a type error>`的讨论，显然，它是一种run-time lazy；Lazyness of template instantiation是一种compile-time lazy。

> NOTE: 不同的translation unit，可能instantiate了同一个template，显然， 它们就包含了相同的instantiation，也就是相同的definition，对于这种情况，一般情况下，compiler是会报multiple definition的，但是对于template，它是会进行特殊处理的。



The definition of a template must be visible at the point of implicit instantiation, which is why template libraries typically provide all template definitions in the headers (e.g. [most boost libraries are header-only](http://www.boost.org/doc/libs/release/more/getting_started/unix-variants.html#header-only-libraries))

> NOTE: 什么叫做implicit instantiation？
>
> 这一段，其实解释了一个问题：
>
> [Why can templates only be implemented in the header file?](https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file)
>
> 其实，我们完全可以从template的static特性出发来进行理解，关于这一点，在“Template is a kind of static polymorphism”中进行了说明。



## Template argument: provided or deduced

本节标题描述的是：获得template argument的两种方式：

- provided：由programmer 显式 提供
- deduced：由compiler 隐式 提供；在`C++\Language-reference\Template\Implementation\Argument-deduction`章节进行专门分析

本节标题中的内容是源自：素材: cppreference [Templates](https://en.cppreference.com/w/cpp/language/templates)。



## Substitution: argument->parameter

本节标题的含有是：将template argument 赋给 template parameter的过程，在C++ template的世界中，一般叫做 **substitution**。

substitution是compiler编译template的过程中的非常重要的一个环节，关于这一点，在下面的文章中提及了：

- thegreenplace [SFINAE and enable_if](https://eli.thegreenplace.net/2014/sfinae-and-enable_if/)
- wikipedia [Substitution failure is not an error](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error)

### SFINAE

在`C++\Idiom\Templates-and-generic-programming\SFINAE-trait-enable-if\SFINAE`中对SFINAE进行了深入分析。



## How dose compiler select from a set of candidates？

最最简单的情况是，仅仅存在**primary template**，此时compiler仅仅根据primary template进行instantiation of template即可。比较复杂的情况是：当存在多个specialization of template的时候，compiler如何选择set  of candidates中的哪个specialization of template进行instantiation？这就是本节标题的含义。

这个过程还是比较复杂的，目前还没有遇到专门描述的文章。

在stackoverflow [How does `void_t` work](https://stackoverflow.com/questions/27687389/how-does-void-t-work)中有所涉及，下面是阅读该文章的一些总结。

- compiler会逐个substitute Primary Class Template、Specialized Class Template

- 首先根据Primary Class Template的替换结果，得到**template parameter list**，然后使用

- 优先级顺序是：Specialized Class Template specialization > Primary Class Template specialization 

  

## 完整的编译过程

需要对template的完整的编译过程有一个高屋建瓴的理解，目前还没有遇到专门描述的文章；可以肯定的是：这个完整的过程，包含了前面描述的一些步骤，但是compiler需要考虑的问题，比上面描述的要多得多。下面的素材: stackoverflow [How does `void_t` work](https://stackoverflow.com/questions/27687389/how-does-void-t-work)结合了一个具体的案例对这个过程进行描述，非常好。



### 素材: stackoverflow [How does `void_t` work](https://stackoverflow.com/questions/27687389/how-does-void-t-work)

> 這是我在學習`void_t`的實現的時候，遇到的一篇講解的比較詳細的、涉及template的實現的文章，我覺得非常好，遂收录在此。



Given a simple **variable template** that evaluates to `void` if all template arguments are well formed:

```c++
template<class ... > using void_t = void;
```

[A](https://stackoverflow.com/a/27688405)

#### 1. Primary Class Template

When you write `has_member<A>::value`, the compiler looks up the name `has_member` and finds the *primary* class template, that is, this declaration:

```cpp
template< class , class = void >
struct has_member;
```

(In the OP, that's written as a definition.)

The template argument list `<A>` is compared to the **template parameter list** of this primary template. Since the primary template has two parameters, but you only supplied one, the remaining parameter is defaulted to the **default template argument**: `void`. It's as if you had written `has_member<A, void>::value`.

> NOTE: 上面这段话中的“template argument list `<A>` ”对应的是“`has_member<A>::value`”中的`A`。
>
> compiler会编译source file，source file中，会`include`定义了primary class template、specialized class template 的header file，所以compiler会同时看到primary class template、specialized class template，并且primary class template在specialized class template之前。
>
> 上面这段话中的**template parameter list**非常重要，后面会使用给它。

#### 2. Specialized Class Template

**Now**, the **template parameter list** is compared against any **specializations** of the template `has_member`. Only if no specialization matches, the definition of the **primary template** is used as a **fall-back**. So the **partial specialization** is taken into account:

```cpp
template< class T >
struct has_member< T , void_t< decltype( T::member ) > > : true_type
{ };
```

The compiler tries to match the template arguments `A, void` with the patterns defined in the **partial specialization**: `T` and `void_t<..>` one by one. ***First***, **template argument deduction** is performed. The partial specialization above is still a template with template-parameters that need to be "filled" by arguments.

**The first pattern** `T`, allows the compiler to deduce the template-parameter `T`. This is a trivial deduction, but consider a pattern like `T const&`, where we could still deduce `T`. For the pattern `T` and the template argument `A`, we deduce `T` to be `A`.

**In the second pattern** `void_t< decltype( T::member ) >`, the template-parameter `T` appears in a context where it cannot be deduced from any template argument.

> There are two reasons for this:
>
> - The expression inside `decltype` is explicitly excluded from **template argument deduction**. I guess this is because it can be arbitrarily complex.
> - Even if we used a pattern without `decltype` like `void_t< T >`, then the deduction of `T` happens on the resolved alias template. That is, we resolve the alias template and later try to deduce the type `T` from the resulting pattern. The resulting pattern, however, is `void`, which is not dependent on `T` and therefore does not allow us to find a specific type for `T`. This is similar to the mathematical problem of trying to invert a constant function (in the mathematical sense of those terms).

> NOTE: 关于`decltype`是Non-deduced contexts，参加cppreference Template argument deduction，其中有专门说明。

Template argument deduction is finished`(*)`, ***now*** the *deduced* template arguments are substituted. This creates a specialization that looks like this:

```cpp
template<>
struct has_member< A, void_t< decltype( A::member ) > > : true_type
{ };
```

The type `void_t< decltype( A::member ) >` can now be evaluated. It is well-formed after substitution, hence, no *Substitution Failure* occurs. We get:

```cpp
template<>
struct has_member<A, void> : true_type
{ };
```

#### 3. Choice

**Now**, we can compare the **template parameter list** of this specialization with the template arguments supplied to the original `has_member<A>::value`. Both types match exactly, so this **partial specialization** is chosen.

------

On the other hand, when we define the template as:

```cpp
template< class , class = int > // <-- int here instead of void
struct has_member : false_type
{ };

template< class T >
struct has_member< T , void_t< decltype( T::member ) > > : true_type
{ };
```

We end up with the same specialization:

```cpp
template<>
struct has_member<A, void> : true_type
{ };
```

but our **template argument list** for `has_member<A>::value` now is `<A, int>`. The arguments do not match the parameters of the specialization, and the primary template is chosen as a fall-back.

------

`(*)` The Standard, IMHO confusingly, includes the substitution process and the matching of explicitly specified template arguments in the *template argument deduction* process. For example (post-N4296) [temp.class.spec.match]/2:

> A partial specialization matches a given actual template argument list if the template arguments of the partial specialization can be deduced from the actual template argument list.

But this does not *just* mean that all template-parameters of the partial specialization have to be deduced; it also means that substitution must succeed and (as it seems?) the template arguments have to match the (substituted) template parameters of the partial specialization. Note that I'm not completely aware of *where* the Standard specifies the comparison between the substituted argument list and the supplied argument list.

### 素材: riptutorial [C++ `void_t`](https://riptutorial.com/cplusplus/example/3778/void-t) 

How does this work? When I try to instantiate `has_foo<T>::value`, that will cause the compiler to try to look for the best specialization for `has_foo<T, void>`. We have two options: the primary, and this secondary one which involves having to instantiate that underlying expression:

- If `T` *does* have a member function `foo()`, then whatever type that returns gets converted to `void`, and the specialization is preferred to the primary based on the template partial ordering rules. So `has_foo<T>::value` will be `true`
- If `T` *doesn't* have such a member function (or it requires more than one argument), then substitution fails for the specialization and we only have the primary template to fallback on. Hence, `has_foo<T>::value` is `false`.

## stackoverflow [Why can templates only be implemented in the header file?](https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file)

20200427: 对这个问题的分析，需要从compiler的compile model入手，在Why can’t I separate the definition of my templates class from its declaration and put it inside a .cpp file? [¶](https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl) [Δ](https://isocpp.org/wiki/faq/templates#)中对此的分析是非常好的。



## TO READ

bytefreaks [C++: “undefined reference to” templated class function](https://bytefreaks.net/programming-2/c/c-undefined-reference-to-templated-class-function)



stackoverflow [“Undefined symbols” linker error with simple template class](https://stackoverflow.com/questions/999358/undefined-symbols-linker-error-with-simple-template-class)



stackoverflow [Template instantiation details of GCC and MS compilers](https://stackoverflow.com/questions/7182359/template-instantiation-details-of-gcc-and-ms-compilers)



gnu [Compiling c++ template is very slow.](https://gcc.gnu.org/legacy-ml/gcc/2018-03/msg00108.html)



oracle [Chapter 7 Compiling Templates](https://docs.oracle.com/cd/E19205-01/819-5267/bkage/index.html)



stackoverflow [Template Compilation](https://stackoverflow.com/questions/19798325/template-compilation)



https://accu.org/index.php/journals/427



为了便于区分，primary template、Specialized template

compiler肯定会substitute所有的template，替换后的的template叫什么名字？叫做specialization of  template

substitute的过程可能会发生失败，它们会被从candidate中drop掉

compiler

对于template specialization

