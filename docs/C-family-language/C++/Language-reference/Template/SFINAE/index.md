# SFINAE

“SFINAE”是“Substitution failure is not an error”的缩写。"substitution"所表示是使用template argument来**substitute** template parameter。

## Why SFINAE ?

本节讨论为什么C++ 会采用 SFINAE。在`C++\Guide\Polymorphism`中，我们已经知道:

1) C++  template [**Parametric polymorphism**](https://en.wikipedia.org/wiki/Parametric_polymorphism)，是一种static polymorphism

2) SFINAE是C++实现"通过**template metaprogramming**(编写metaprogram)来对**static polymorphism**的过程进行控制"的基础。

本节对这个问题进行深入分析。

### 遵循try my best原则

> SFINAE遵循try my best原则

"try my best原则"是实现polymorphism的主要原则，在`Theory\Programming-paradigm\Abstraction-and-polymorphism\Polymorphism\Implementation`中对它进行了讨论。下面结合SFINAE来进行说明: 

SFINAE 是 compiler 编译机制(或者说: 原理)，它保证了compiler会对每个candidate都执行替换(校验)，中途出现错误则将当前candidate给drop调，并不会终止，而是去尝试下一个candidate，直至尝试了所有的candidate。这个过程是遵循在`Theory\Programming-paradigm\Abstraction-and-polymorphism\Polymorphism\Implementation`中提出的"try my best原则"原则的，显然这样做的目标地是: 保证了compiler能够选择最合适的实现(implementation/concrete)；

### SFINAE是实现对**static polymorphism**的过程进行控制的基础

在cppreference [Templates](https://en.cppreference.com/w/cpp/language/templates)中有如下介绍：

> When a **class template specialization** is referenced in context that requires a complete object type, or when a **function template specialization** is referenced in context that requires a function definition to exist, the template is *instantiated* (the code for it is actually compiled), unless the template was already explicitly specialized or explicitly instantiated. Instantiation of a class template doesn't instantiate any of its member functions unless they are also used. At link time, identical instantiations generated by different translation units are merged.

简而言之，template是只有在使用的情况下才会被“instantiation”，**SFINAE**控制了对**template specialization**(concrete/implementation)的**选择**，实现了

1) conditional compiling，此处的又可以称为: compile-time dispatch

2) 对**static polymorphism**的过程进行控制

C++支持template function、template class，它们都可以通过SFINA来进行控制：

1 Controlling overload resolution: [function overloads](https://en.wikipedia.org/wiki/Overload_resolution) 

> NOTE: 参见：https://foonathan.net/2015/11/overload-resolution-4/

2 Controlling template specializations



SFINAE 超过type的限制，允许programmer灵活地进行dispatch，比如：

- 基于concept进行dispatch
- 根据消息类型来进行dispatch，消息类型是enum，是integer，不是type，无法按照type来进行dispatch，只能使用SFIANE（AMUSTAPI是一个非常好的例子）



## wikipedia [Substitution failure is not an error](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error)

**Substitution failure is not an error** (**SFINAE**) refers to a situation in [C++](https://en.wikipedia.org/wiki/C%2B%2B) where an invalid substitution of [template](https://en.wikipedia.org/wiki/Template_(C%2B%2B)) parameters is not in itself an error.

> NOTE: SFINAE遵循try my best原则，在上面的"遵循try my best原则"段对这样做的原因进行了解释。

### Example

```c++
#include <iostream>
struct Test
{
	typedef int foo;
};
// Definition #1
template<typename T>
void f(typename T::foo)
{
	std::cout << __PRETTY_FUNCTION__ << std::endl;
}
// Definition #2
template<typename T>
void f(T)
{
	std::cout << __PRETTY_FUNCTION__ << std::endl;
}

int main()
{
	f<Test>(10);  // Call #1.
	f<int>(10);   // Call #2. Without error (even though there is no int::foo)
				  // thanks to SFINAE.
}
// g++ test.cpp
```

> NOTE: 上述程序的输出如下:
>
> ```c++
> void f(typename T::foo) [with T = Test; typename T::foo = int]
> void f(T) [with T = int]
> 
> ```
>
> 

Although SFINAE was initially introduced to avoid creating ill-formed programs when unrelated template declarations were visible (e.g., through the inclusion of a header file), many developers later found the behavior useful for **compile-time introspection**. Specifically, it allows a template to determine certain properties of its **template arguments** at instantiation time.

> NOTE: **compile-time introspection**是C++20的[concept](https://en.cppreference.com/w/cpp/language/constraints)所要解决的。

```c++
#include <iostream>

template<typename T>
struct has_typedef_foobar
{
	// Types "yes" and "no" are guaranteed to have different sizes,
	// specifically sizeof(yes) == 1 and sizeof(no) == 2.
	typedef char yes[1];
	typedef char no[2];

	template<typename C>
	static yes& test(typename C::foobar*);

	template<typename >
	static no& test(...);

	// If the "sizeof" of the result of calling test<T>(nullptr) is equal to
	// sizeof(yes), the first overload worked and T has a nested type named
	// foobar.
	static const bool value = sizeof(test<T>(nullptr)) == sizeof(yes);
};

struct foo
{
	typedef float foobar;
};

int main()
{
	std::cout << std::boolalpha;
	std::cout << has_typedef_foobar<int>::value << std::endl;  // Prints false
	std::cout << has_typedef_foobar<foo>::value << std::endl;  // Prints true
}
// g++ --std=c++11 test.cpp

```

> NOTE: 上述代码是detection idiom 

When `T` has the nested type `foobar` defined, the instantiation of the first `test` works and the null pointer constant is successfully passed. (And the resulting type of the expression is `yes`.) If it does not work, the only available function is the second `test`, and the resulting type of the expression is `no`. An **ellipsis** is used not only because it will accept any argument, but also because its **conversion rank** is lowest, so a call to the first function will be preferred if it is possible; this removes ambiguity.

> NOTE: 这个技巧需要好好学习

### C++11 simplification

In [C++11](https://en.wikipedia.org/wiki/C%2B%2B11), the above code could be simplified to:

```c++
#include <iostream>
#include <type_traits>

template<typename ... Ts>
using void_t = void;

template<typename T, typename = void>
struct has_typedef_foobar: std::false_type
{
};

template<typename T>
struct has_typedef_foobar<T, void_t<typename T::foobar>> : std::true_type
{
};

struct foo
{
	using foobar = float;
};

int main()
{
	std::cout << std::boolalpha;
	std::cout << has_typedef_foobar<int>::value << std::endl;
	std::cout << has_typedef_foobar<foo>::value << std::endl;
}
// g++ --std=c++11 test.cpp

```

> NOTE: 
>
> 运行结果如下:
>
> ```C++
> true
> true
> ```
>
> 通过上述运行结果来看，`void_t`并没有生效，具体原因在cppreference [std::void_t](https://en.cppreference.com/w/cpp/types/void_t) 中给出了解释。
>
> 关于正确的实现，参见
>
> 1) `C++\Library\Standard-library\Utility-library\Language-support\Type-support\Type-traits\Type-transformations\void_t`章节。
>
> 2) `C++\Language-reference\Template\Programming-paradigm\Idioms\Detection`章节

## cppreference [sfinae](https://en.cppreference.com/w/cpp/language/sfinae)

### [Explanation](https://en.cppreference.com/w/cpp/language/sfinae#Explanation)



### [Type SFINAE](https://en.cppreference.com/w/cpp/language/sfinae#Type_SFINAE)

> NOTE: 参见[Class-template-SFINAE](./Class-template-SFINAE.md)。

### [Expression SFINAE](https://en.cppreference.com/w/cpp/language/sfinae#Expression_SFINAE)

> NOTE: 参见[Expression-SFINAE](./Expression-SFINAE.md)。

### [Library support](https://en.cppreference.com/w/cpp/language/sfinae#Library_support)



### [Alternatives](https://en.cppreference.com/w/cpp/language/sfinae#Alternatives)

Where applicable, [tag dispatch](https://en.cppreference.com/w/cpp/iterator/iterator_tags#Example), [static_assert](https://en.cppreference.com/w/cpp/language/static_assert), and, if available, [concepts](https://en.cppreference.com/w/cpp/language/constraints), are usually preferred over direct use of SFINAE.



## Example: conditional compiling by detection idiom

下面是碰到过的一个例子：

如果结构体有字段`AccountIndex`，则使用它的`AccountIndex`字段来作为token，否则使用另外一种获取token的算法，通过`has_member_AccountIndex` trait来判断结构体是否有字段`AccountIndex`，下面是我第一次的实现：

```c++
template<typename ReqFieldType>
TokenType GetToken(ReqFieldType* ReqField)
{
    TokenType Token;
    if(has_member_AccountIndex<ReqFieldType>::value)
    {
        Token  = ReqField->AccountIndex;
    }
	else
    {
        Token = Algorithm2();
    }
		return Token;
}
```

上述程序算法无法编译通过的，因为当给函数GetToken提供一个没有字段`AccountIndex`的`ReqFieldType`时，compiler在编译`Token  = ReqField->AccountIndex;`时，是会complain：`ReqFieldType`没有字段`AccountIndex`的。

所以，我们需要使用conditional compiling，下面是实现代码：

```c++
	template<typename ReqFieldType>
	auto GetToken(ReqFieldType* ReqField)->typename std::enable_if< has_member_AccountIndex<ReqFieldType>::value, TokenType>::type
	{
		TokenType Token  = ReqField->AccountIndex;
		return Token;
	}


	template<typename ReqFieldType>
	auto GetToken(ReqFieldType* ReqField)->typename std::enable_if<has_member_AccountIndex<ReqFieldType>::value, TokenType>::type
	{
        TokenType Token = Algorithm2();
		return Token;
	}
```

### C++17 `constexpr if`

C++17 `constexpr if` 能够对上述代码进行简化，参见`C++\Language-reference\Statements\Selection-statements\Constexpr-if.md`。



## TO READ



https://www.bfilipek.com/2016/02/notes-on-c-sfinae.html

https://www.fluentcpp.com/2018/05/18/make-sfinae-pretty-2-hidden-beauty-sfinae/


https://www.modernescpp.com/index.php/c-20-concepts-the-details

https://jguegant.github.io/blogs/tech/sfinae-introduction.html