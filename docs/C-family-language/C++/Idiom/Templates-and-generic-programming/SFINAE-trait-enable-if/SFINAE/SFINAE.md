# SFINAE

“SFINAE”是“Substitution failure is not an error”的缩写。SFINAE和C++的特性`template`相关，"substitution"所表示是使用template argument来**substitute** template parameter。

## SFINAE and conditional compiling/dispatch

SFINAE是template的特性，在cppreference [Templates](https://en.cppreference.com/w/cpp/language/templates)中有如下介绍：

> When a class template specialization is referenced in context that requires a complete object type, or when a function template specialization is referenced in context that requires a function definition to exist, the template is *instantiated* (the code for it is actually compiled), unless the template was already explicitly specialized or explicitly instantiated. Instantiation of a class template doesn't instantiate any of its member functions unless they are also used. At link time, identical instantiations generated by different translation units are merged.

简而言之，template是只有在使用的情况下才会被“instantiation”，SFINAE控制了对template的选择，进而实现conditional compiling（conditional compiling又可以称为：compile-time dispatch）; 

C++支持template function、template class，它们都可以通过SFINA来进行控制：

- Controlling overload resolution: [function overloads](https://en.wikipedia.org/wiki/Overload_resolution) 

  > NOTE: 参见：https://foonathan.net/2015/11/overload-resolution-4/

- Controlling template specializations

SFINAE 超过type的限制，允许programmer灵活地进行dispatch，比如：

- 基于concept进行dispatch
- 根据消息类型来进行dispatch，消息类型是enum，是integer，不是type，无法按照type来进行dispatch，只能使用SFIANE（AMUSTAPI是一个非常好的例子）



## 维基百科[Substitution failure is not an error](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error)



### Example

```c++
struct Test {
  typedef int foo;
};

template <typename T>
void f(typename T::foo) {}  // Definition #1

template <typename T>
void f(T) {}  // Definition #2

int main() {
  f<Test>(10);  // Call #1.
  f<int>(10);   // Call #2. Without error (even though there is no int::foo)
                // thanks to SFINAE.
}
```

Although SFINAE was initially introduced to avoid creating ill-formed programs when unrelated template declarations were visible (e.g., through the inclusion of a header file), many developers later found the behavior useful for **compile-time introspection**. Specifically, it allows a template to determine certain properties of its **template arguments** at instantiation time.

> NOTE: **compile-time introspection**是c++20的[concept](https://en.cppreference.com/w/cpp/language/constraints)所要解决的。

```c++
#include <iostream>

template <typename T>
struct has_typedef_foobar {
  // Types "yes" and "no" are guaranteed to have different sizes,
  // specifically sizeof(yes) == 1 and sizeof(no) == 2.
  typedef char yes[1];
  typedef char no[2];

  template <typename C>
  static yes& test(typename C::foobar*);

  template <typename>
  static no& test(...);

  // If the "sizeof" of the result of calling test<T>(nullptr) is equal to
  // sizeof(yes), the first overload worked and T has a nested type named
  // foobar.
  static const bool value = sizeof(test<T>(nullptr)) == sizeof(yes);
};

struct foo {
  typedef float foobar;
};

int main() {
  std::cout << std::boolalpha;
  std::cout << has_typedef_foobar<int>::value << std::endl;  // Prints false
  std::cout << has_typedef_foobar<foo>::value << std::endl;  // Prints true
}
// 编译g++ --std=c++11 test.cpp

```

> NOTE: 上述代码是detection idiom 

When `T` has the nested type `foobar` defined, the instantiation of the first `test` works and the null pointer constant is successfully passed. (And the resulting type of the expression is `yes`.) If it does not work, the only available function is the second `test`, and the resulting type of the expression is `no`. An ellipsis is used not only because it will accept any argument, but also because its conversion rank is lowest, so a call to the first function will be preferred if it is possible; this removes ambiguity.

> NOTE: 这个技巧需要好好学习

### C++11 simplification

In [C++11](https://en.wikipedia.org/wiki/C%2B%2B11), the above code could be simplified to:

```c++
#include <iostream>
#include <type_traits>

template <typename... Ts>
using void_t = void;

template <typename T, typename = void>
struct has_typedef_foobar : std::false_type {};

template <typename T>
struct has_typedef_foobar<T, void_t<typename T::foobar>> : std::true_type {};

struct foo {
  using foobar = float;
};

int main() {
  std::cout << std::boolalpha;
  std::cout << has_typedef_foobar<int>::value << std::endl;
  std::cout << has_typedef_foobar<foo>::value << std::endl;
}
// g++ --std=c++11 test.cpp

```

> NOTE: 上述代码也是detection idiom。

## cppreference [sfinae](https://en.cppreference.com/w/cpp/language/sfinae)

### [Explanation](https://en.cppreference.com/w/cpp/language/sfinae#Explanation)



### [Type SFINAE](https://en.cppreference.com/w/cpp/language/sfinae#Type_SFINAE)

> NOTE: 参见[Class-template-SFINAE](./Class-template-SFINAE.md)。

### [Expression SFINAE](https://en.cppreference.com/w/cpp/language/sfinae#Expression_SFINAE)

> NOTE: 参见[Expression-SFINAE](./Expression-SFINAE.md)。

### [Library support](https://en.cppreference.com/w/cpp/language/sfinae#Library_support)



### [Alternatives](https://en.cppreference.com/w/cpp/language/sfinae#Alternatives)

Where applicable, [tag dispatch](https://en.cppreference.com/w/cpp/iterator/iterator_tags#Example), [static_assert](https://en.cppreference.com/w/cpp/language/static_assert), and, if available, [concepts](https://en.cppreference.com/w/cpp/language/constraints), are usually preferred over direct use of SFINAE.



## Example: conditional compiling by detection idiom

下面是碰到过的一个例子：

如果结构体有字段`AccountIndex`，则使用它的`AccountIndex`字段来作为token，否则使用另外一种获取token的算法，通过`has_member_AccountIndex` trait来判断结构体是否有字段`AccountIndex`，下面是我第一次的实现：

```c++
template<typename ReqFieldType>
TokenType GetToken(ReqFieldType* ReqField)
{
    TokenType Token;
    if(has_member_AccountIndex<ReqFieldType>::value)
    {
        Token  = ReqField->AccountIndex;
    }
	else
    {
        Token = Algorithm2();
    }
		return Token;
}
```

上述程序算法无法编译通过的，因为当给函数GetToken提供一个没有字段`AccountIndex`的`ReqFieldType`时，compiler在编译`Token  = ReqField->AccountIndex;`时，是会complain：`ReqFieldType`没有字段`AccountIndex`的。

所以，我们需要使用conditional compiling，下面是实现代码：

```c++
	template<typename ReqFieldType>
	auto GetToken(ReqFieldType* ReqField)->typename std::enable_if< has_member_AccountIndex<ReqFieldType>::value, TokenType>::type
	{
		TokenType Token  = ReqField->AccountIndex;
		return Token;
	}


	template<typename ReqFieldType>
	auto GetToken(ReqFieldType* ReqField)->typename std::enable_if<has_member_AccountIndex<ReqFieldType>::value, TokenType>::type
	{
        TokenType Token = Algorithm2();
		return Token;
	}
```

### C++17 `constexpr if`

C++17 `constexpr if` 能够对上述代码进行简化，参见`C++\Language-reference\Statements\Selection-statements\Constexpr-if.md`。



## concept and sfinae

SFINAE是一种事前检查，C++ concept也是一种事前检查，不过C++ concept的语法更加清晰易读。

https://stackoverflow.com/questions/28133118/will-concepts-replace-sfinae



## TO READ



https://www.bfilipek.com/2016/02/notes-on-c-sfinae.html

https://www.fluentcpp.com/2018/05/18/make-sfinae-pretty-2-hidden-beauty-sfinae/


https://www.modernescpp.com/index.php/c-20-concepts-the-details

