<!DOCTYPE html>
<!-- saved from url=(0050)https://www.artima.com/cppsource/type_erasure.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>On the Tension Between Object-Oriented and Generic Programming in C++</title>

<meta name="description" content="
">
<meta name="keywords" content="">
<meta name="author" content="Thomas Becker">
<link rel="stylesheet" type="text/css" href="./On the Tension Between Object-Oriented and Generic Programming in C++_files/artima.css">
<link rel="shortcut icon" href="https://www.artima.com/favicon.ico">
</head>
<body><table width="100%" bgcolor="#FFFFFF" style="margin-top: 5px">
<tbody><tr>
<td align="center">
<div id="topbanner" style="height: 90px"><noscript><a href='https://www.artima.com/zcr/adclick.php?n=a86d37e9' target='_top'><img src='https://www.artima.com/zcr/adview.php?what=zone:1&amp;n=a86d37e9' border='0' alt='' /></a></noscript></div>
</td>
</tr>
</tbody></table>
<table width="100%" cellspacing="0">
<tbody><tr>
<td align="left" valign="bottom">
<a href="https://www.artima.com/index.jsp"><img src="./On the Tension Between Object-Oriented and Generic Programming in C++_files/a7.gif" alt="The Artima Developer Community" border="0" width="550" height="43"></a>
</td>
</tr></tbody></table>
<table width="100%" bgcolor="#333333">
<tbody><tr>
<td align="center">
<div class="ml">
<a href="https://www.artima.com/articles" class="hl">Articles</a>&nbsp;|
<a href="https://www.artima.com/news/index.jsp" class="hl">News</a>&nbsp;|
<a href="https://www.artima.com/weblogs/index.jsp" class="hl">Weblogs</a>&nbsp;|
<a href="https://www.artima.com/shop/catalog" class="hl">Books</a>&nbsp;|
<a href="https://www.artima.com/forums/index.jsp" class="hl">Forums</a>
</div>
</td>
</tr>
</tbody></table>
<table width="100%" bgcolor="#CCCCFF">
<tbody><tr>
<td align="center">
<div class="sc">
<a href="https://www.artima.com/cppsource/index.html">The C++ Source</a>&nbsp;| 
<a href="https://www.artima.com/groups/group.jsp?group=cpp">C++ Community News</a>&nbsp;| 
<a href="https://www.artima.com/forums/flat.jsp?forum=226&amp;thread=216972">Discuss</a>&nbsp;| 
<a href="mailto:?subject=On%20the%20Tension%20Between%20Object-Oriented%20and%20Generic%20Programming%20in%20C++&amp;body=%20%0AOn%20the%20Tension%20Between%20Object-Oriented%20and%20Generic%20Programming%20in%20C++%20%0Aand%20What%20Type%20Erasure%20Can%20Do%20About%20It%20%0Aby%20Thomas%20Becker%20%0A%0Ahttps://www.artima.com/cppsource/type_erasure.html">Email</a>&nbsp;| 
Previous&nbsp;| 
Next
</div>
</td>
</tr>
</tbody></table>
<table width="100%" bgcolor="#EEEEEE">
<tbody><tr>
<td align="center">
<div class="sc">
<span style="color: #555555">Sponsored Link</span> <span style="color: #888888">•</span> 
<script language="JavaScript" type="text/javascript" src="./On the Tension Between Object-Oriented and Generic Programming in C++_files/adx.js.download"></script>
<script language="JavaScript" type="text/javascript">
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("https://www.artima.com/zcr/adjs.php?n=" + phpAds_random);
   document.write ("&amp;what=zone:9&amp;target=_top");   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
//-->
</script><noscript><a href='https://www.artima.com/zcr/adclick.php?n=a799ecf6' target='_top'><img src='https://www.artima.com/zcr/adview.php?what=zone:9&amp;n=a0587811' border='0' alt=''></a></noscript>
</div>
</td>
</tr>
</tbody></table>
<br>
<div class="vegies">
<div class="tc">
<span class="sts">C++ Source</span><br>
<span class="ts">On the Tension Between Object-Oriented and Generic Programming in C++</span><br>
<span class="sts">and What Type Erasure Can Do About It</span><br>
<span class="as">by Thomas Becker</span><br>
<span class="pd">October 15, 2007</span><br>
</div>
<p>

</p><table align="right" border="0" cellpadding="5" cellspacing="0">

<tbody><tr>

<td align="center">

<div style="margin-left: 15%;">

<div class="adnotice">Advertisement</div>
<script language="JavaScript" type="text/javascript" src="./On the Tension Between Object-Oriented and Generic Programming in C++_files/adx.js.download"></script>
<script language="JavaScript" type="text/javascript">
<!--
   if (!document.phpAds_used) document.phpAds_used = ',';
   phpAds_random = new String (Math.random()); phpAds_random = phpAds_random.substring(2,11);
   
   document.write ("<" + "script language='JavaScript' type='text/javascript' src='");
   document.write ("https://www.artima.com/zcr/adjs.php?n=" + phpAds_random);
   document.write ("&amp;what=zone:2&amp;target=_top&amp;block=1&amp;blockcampaign=1");
   document.write ("&amp;exclude=" + document.phpAds_used);
   if (document.referrer)
      document.write ("&amp;referer=" + escape(document.referrer));
   document.write ("'><" + "/script>");
//-->
</script><noscript><a href='https://www.artima.com/zcr/adclick.php?n=a799ecf6' target='_top'><img src='https://www.artima.com/zcr/adview.php?what=zone:2&amp;n=a799ecf6' border='0' alt=''></a></noscript>
</div>

</td>

</tr>

</tbody></table>

<p></p>

  <title></title>
<!-- TOP OF SUMMARY -->
  <div class="summary">
    <div class="summarytitle">
      Summary
    </div>The author discusses how the use of generic programming
    in C++ can lead to conflicts with object-oriented design
    principles. He demonstrates how a technique known as type
    erasure can often be used to resolve these conflicts. An
    in-depth example is presented: <code>any_iterator</code>, a
    type-safe, heterogeneous C++ iterator.
  </div>
<!-- BOTTOM OF SUMMARY -->
  <p>In his glossary of terms[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">1</a>], Bjarne Stroustrup has
  described the C++ programming language that he created as "a
  general-purpose programming language [...] that supports
  procedural programming, data abstraction, object-oriented
  programming, and generic programming." The fact that C++ supports
  these different programming paradigms makes it unique—and
  uniquely powerful—among today's programming languages. On the
  other hand, it should not come as a surprise that the close
  coexistence of such vastly different paradigms can cause
  considerable friction, especially in large software systems.</p>
  <p>In this article, I will focus on the tension that can occur
  when object-oriented programming (classes, objects, and runtime
  polymorphism come to mind) meets generic programming (algorithms,
  templates, and compile time polymorphism come to mind).</p>
  <p>The article consists of two parts. In the first part, I will
  demonstrate how the coexistence of OO and generic programming can
  cause serious friction in real-life software engineering. I will
  then explain how a technique known as type erasure can be used to
  alleviate these problems.</p>
  <p>The second part explains how type erasure can be implemented
  in C++. Specifically, I will elaborate on an example used in the
  first part, namely, C++ iterator type erasure. I will discuss the
  design and implementation of a class template[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">2</a>] <code>any_iterator</code> that
  provides type erasure for C++ iterators.</p>
  <h1>The Trouble with Object-Oriented and Generic Programming</h1>
  <h2>A Little Trivia Quiz</h2>
  <p>Let us start with a little trivia quiz. Who said the following
  things about object-oriented programming?</p>
  <p>"I find OOP technically unsound."</p>
  <p>"I find OOP philosophically unsound."</p>
  <p>"I find OOP methodologically wrong."</p>
  <p>"I have yet to see an interesting piece of code that comes
  from these OO people."</p>
  <p>"I think that object orientedness is almost as much of a hoax
  as artificial intelligence."</p>
  <p>All the quotes above are from an interview with Alexander
  Stepanov[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">3</a>], the inventor
  of the STL and elder statesman of generic programming. As a
  practicing software engineer who works on large commercial
  software projects, I know better than to hold such a negative
  view of OO programming. But when someone like Alexander Stepanov
  says such a thing, then I don't think it should be taken
  lightly.</p>
  <p>My experience as a software engineer in the trenches has
  taught me that there is much more tension, if not contradiction
  or incompatibility, between OO programming and generic
  programming than many people care to admit. It is easy to dismiss
  Alexander Stepanov's rejection of OO programming as extreme and
  unrealistic. It is much harder to make the OO and generic
  programming paradigms coexist and cooperate in real-life software
  engineering.</p>
  <p>In the next three sections, I will illustrate the problem with
  an example from the real world, and I will suggest a less radical
  remedy than to disavow OO programming as a tool in software
  design altogether.</p>
  <h2>An Example from the Real World</h2>
  <p>Suppose you have a class <code>number_cruncher</code> that
  calculates and stores a sequence of numbers. Further, suppose
  that <code>number_cruncher</code> wants to expose to its clients
  a way to iterate over the stored numbers and retrieve them.</p>
  <p>In the old days, predating the STL, the interface of
  <code>number_cruncher</code> might have exposed a callback for
  retrieving the numbers, or perhaps some form of
  <code>get_first()</code>/<code>get_next()</code> idiom. In an
  evironment where the STL and generic programming are used, such
  an interface would raise more than a few eyebrows. Here, the
  interface of <code>number_cruncher</code> will expose a pair of
  iterators, like this:</p>
  <pre>class number_cruncher
{   
public:
  typedef std::vector&lt;double&gt;::const_iterator const_iterator;
  const_iterator begin() const;
  const_iterator end() const;
  [...]
};
</pre>
  <p>Now suppose you change the type of the collection which
  internally holds the items from <code>std::vector</code> to some
  other kind of vector. (Yes, there are other kinds of vectors.) In
  the sense of OO programming, what have you just done? You have
  changed an implementation detail. And what happens? The world
  recompiles. By using a typedef for the iterator that you expose,
  you were able to ensure that your clients did not have to change
  their code. Nonetheless, their code depends on the type of the
  iterator, and thus on the type of the collection that you use to
  store your numbers. In the pre-STL design mentioned earlier, this
  dependency can easily be eliminated, e.g., by using the pimpl
  idiom, or by exposing the number cruncher's interface via an
  abstract base class. This option is now gone. By using the
  typedef for the iterators, you have introduced a compile-time
  dependency that cannot be eliminated. Depending on the context in
  which your class is used, that may or may not be a serious
  issue.</p>
  <p>But it gets worse. Suppose that the implementation of
  <code>number_cruncher</code> changes in such a way that there are
  frequent insertions to the internal collection of numbers. Having
  anticipated a change of that kind, you have carefully specified
  <code>number_cruncher</code>'s interface to state that it will
  expose a pair of input iterators, dereferencing to something that
  converts to a double, with incrementing and dereferencing both
  having O(1) complexity. Therefore, you are within your rights
  when you change the internal type of your collection from
  <code>std::vector&lt;double&gt;</code> to
  <code>std::list&lt;double&gt;</code>. Again, your clients will
  have to recompile. But it is also possible that before, when you
  were exposing vector iterators, some of your clients may have
  said, gee, I wonder how many elements there are in this number
  cruncher. Let me do:</p>
  <pre>size_t numItems = 
  my_number_cruncher.end() - my_number_cruncher.begin();
</pre>
  <p>You did not mean for them to do that, but you could not
  prevent it either. Now, after you changed an implementation
  detail of <code>number_cruncher</code>, not only will the world
  recompile, the world will find that it has a broken build. By
  exposing functionality that you neither needed nor wanted to
  expose, you have broken encapsulation.</p>
  <p>Well, that's not really an issue, you might say, because if
  your clients are STL savvy, as they should be, then they were
  probably using <code>std::distance</code> to get the number of
  elements in the <code>number_cruncher</code>:</p>
  <pre>size_t numItems = std::distance(
  my_number_cruncher.begin(),
  my_number_cruncher.end()
);
</pre>
  <p>If they were doing that, then your implementation change from
  vector to list causes the semantics of your number cruncher to
  change: the cost of getting the number of elements changes from
  constant to linear. This is probably even worse than the broken
  build, because it may not be noticed until way, way later, when
  something goes horribly awry in the field. You never meant for
  anybody to get the number of elements in constant time, but you
  could not prevent it.</p>
  <p>Perhaps you think that none of these problems so far are very
  serious or very likely to happen in practice. Well, ok, I will
  admit that I made all this up. I have never changed an
  <code>std::vector</code> to a different kind of vector, and
  changing an <code>std::vector</code> to an <code>std::list</code>
  is extremely rare and has never caused me the kind of grief that
  I described above. But here's something quite similar that has
  actually happened to me.</p>
  <p>Being a scientific programmer, I find myself writing classes
  that calculate sequences of numbers, store them internally, and
  expose them to clients. Hence the <code>number_cruncher</code>
  example above. In this case, my number cruncher class had to
  calculate several sequences of numbers, and there were certain
  fairly simple relationships between these sequences. For example,
  sequence D was a constant multiple of sequence A, sequence E was
  the pointwise difference between sequences B and C, sequence F
  was the quotient of sequences D and E, and so on and so forth. It
  would have been a silly time-space trade-off for me to store each
  one of these sequences in a collection. Instead, I stored only
  sequences A, B, and C. Sequences D, E, and F were exposed via
  suitable combinations of <code>boost::transform_iterator</code>
  and <code>boost::zip_iterator</code>. These iterators calculate
  the respective value on the fly during dereferencing. The
  interface of the <code>number_cruncher</code> class ended up
  looking like this:</p>
  <pre>class number_cruncher
{
public:
  typedef std::vector&lt;double&gt;::const_iterator a_iterator;
  typedef a_iterator b_iterator;
  typedef a_iterator c_iterator;
  typedef boost::transform_iterator&lt;
    boost::function&lt;double (double)&gt;,
    std::vector&lt;double&gt;::const_iterator
  &gt; d_iterator;
  [...]

  boost::range&lt;a_iterator&gt; get_a_sequence();
  boost::range&lt;b_iterator&gt; get_b_sequence();
  boost::range&lt;c_iterator&gt; get_c_sequence();
  boost::range&lt;d_iterator&gt; get_d_sequence();
  [...]
};
</pre>
  <p>This design obviously suffers from compile-time dependencies
  just as the simpler examples that we considered earlier. Whenever
  I see fit to rearrange my sequences internally, e.g., by storing
  sequences C and E and have my iterators calculate B as the sum of
  C and E, then my clients have to recompile. But that wasn't
  really an issue. Still, I was faced with a full-scale revolt on
  the part of my clients, who accused me of delivering an
  abomination of an interface.</p>
  <p>I should first point out that, as it always happens in
  real-life software, the number of sequences involved started out
  rather small but soon reached several dozen. Also, each of these
  sequences had a domain-related meaning. Therefore, there already
  was an enum to identify each sequence. Now let us analyze what
  kind of an interface my clients can rightfully expect of me from
  an object-oriented point of view. Please bear in mind that I am
  not talking about performance issues yet. I just want to analyze
  the situation from an OO perspective.</p>
  <p>Remember, in the world of OO programming, an interface exposes
  <em>what an object does for its clients</em>, not what the object
  <em>is</em>, and not <em>how</em> it does what it does. What is
  my number cruncher supposed to do for its clients? They have an
  enum value, and they need the corresponding sequence of numbers
  in the form of a pair of input iterators that dereference to a
  double. There can be little doubt as to what kind of interface we
  should see on an object that provides this service:</p>
  <pre>class number_cruncher
{
public:
  boost::range&lt;number_iterator&gt; 
  get_sequence(sequence_type type);
};
</pre>
  <p>Instead, my interface is bloated and cluttered with
  information that has a lot to do with <em>how</em> my number
  cruncher does what it does, and nothing with <em>what it does for
  its clients</em>. Focusing on the various iterator types in my
  interface, we see that they expose to the client what they
  <em>are</em>, when all that matters is <em>what they do for the
  client</em>. The standard solution in OO programming is to employ
  runtime polymorphism to treat these different types uniformly at
  runtime.</p>
  <p>We see that from on OO perspective, my clients complaints are
  entirely justified: failure to employ runtime polymorphism has
  led to a poorly designed interface and strong compile-time
  dependencies.</p>
  <p>There are, of course, many more examples for this kind of
  tension between OO programming and generic programming. The
  common deeper reason behind all those examples is the different
  role that type plays in OO programming and in generic
  programming. In OO programming, the judicious choice of
  user-defined types is a very important, if not the most
  important, design tool. Take one look at any high-level book on
  OO analysis and design, and you'll find that it's all about the
  proper choice of classes and the inheritance relationships
  between them. In generic programming, on the other hand, the type
  system has a tendency to get away from the software designer.
  Types often end up being unrelated despite the fact that the
  things they represent are very much related. In other words, the
  multitude of types is merely a side effect of some generic
  programming technique such as policy driven design or some such
  thing. Were it not for these techniques, one would have never
  designed the user-defined types in that way.</p>
  <h2>Now What?</h2>
  <p>So now we know that generic programming idioms and OO design
  principles have a tendency to conflict. However, I don't believe
  that throwing out one or the other is a very practical solution.
  In order to successfully design and implement large software
  systems, we must avail ourselves of OO principles as well as
  generic programming techniques. What we—and by we I mean all of
  us, C++ gurus, authors, speakers, consultants as well as software
  engineers in the trenches—must understand is this:</p>
  <center>
    <table width="680" border="1" cellpadding="5">
      <tbody><tr>
        <td>Good engineering involves compromise at every turn. A
        good, working, finished product is never pure by the
        standards of any one idiom or methodology. The art of good
        engineering is not the art of discovering and applying the
        one right idiom over all others. The art of good
        engineering is to know what your options are, and then to
        choose your trade-offs wisely rather than letting others
        choose them for you.</td>
      </tr>
    </tbody></table>
  </center>
  <p>Stepping off my soapbox, what does this embrace of compromise
  imply for the examples of the previous section? Well, compromise
  is never easy. It's a pretty messy thing most of the time. That's
  why people love that pure, squeaky-clean, holier-than-thou
  absolute truth that is being preached at every street corner (and
  at many software development conferences as well, for that
  matter).</p>
  <p>It is true that whenever you expose a pair of STL iterators
  such as <code>std::vector&lt;double&gt;::const_iterator</code>
  through a class interface, you are introducing a compile-time
  dependency. Moreover, as we saw in the previous section, you are
  getting precariously close to violating basic principles of OO
  programming such as encapsulation and the proper design of
  interfaces. But you also have an advantage on your side: when the
  compiler is through with its inlining, your vector iterators are
  quite likely to perform as efficiently as plain pointers. This
  performance gain may well justify the sacrifice of OO purity. The
  important thing to understand is that there is a trade-off to be
  made here. It is not uncommon in scientific programming that the
  performance gain afforded by generic programming techniques is
  indispensable. But it is equally common in large software systems
  that there are other performance bottlenecks that render this
  performance gain insignificant.</p>
  <p>It seems to me that as far as the trade-off between OO purity
  and efficiency is concerned, the pendulum in the C++ community
  has swung to the efficiency extreme. In the 1990's, it was all
  about object-oriented analysis and design. Any mention of
  performance issues in connection with runtime polymorphism was
  dismissed as "the old C way of thinking." Today, it's the other
  way round: any proposal to replace or enhance a generic
  programming solution with something that involves an extra
  virtual function call will inevitably be met with the objection
  that it is "too slow." This kind of knee-jerk reaction is not
  useful in real-life software engineering. I always thought that
  the old adage concerning optimization and its relation to evil
  was enough guidance in this respect. But perhaps a more poignant
  one is needed:</p>
  <center>
    <table width="680" border="1" cellpadding="5">
      <tbody><tr>
        <td>Optimization whose effect no user ever notices is the
        root of many evils, among them the failure of software
        projects and the subsequent failure of businesses.</td>
      </tr>
    </tbody></table>
  </center>
  <p>So assume that you are in a similar situation as I was with my
  bad number cruncher interface. Your clients demand a more
  OO-compliant design, and they are perfectly willing to pay a
  performance penalty on the order of magnitude of a virtual
  function call for each iterator operation. This is the time to
  consider <em>type erasure</em> as a solution. So what is type
  erasure, and how can it help us out here?</p>
  <h2>Type Erasure as the Glue between OO and Generic
  Programming</h2>
  <p>In their book on C++ template metaprogramming[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">4</a>], Dave Abrahams and Aleksey
  Gurtovoy define type erasure as "the process of turning a wide
  variety of types with a common interface into one type with
  <em>that same interface</em>."</p>
  <p>The most widely known and used examples of type erasure are
  <code>boost::any</code>[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">5</a>]
  and <code>boost::function</code>[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">6</a>]. I'll discuss
  <code>boost::any</code> in detail in the second part of this
  article. <code>boost::function</code> is a class template that
  takes one template argument, a function type. Choosing a function
  type amounts to choosing a return type and a list of argument
  types for a function. Suppose we instantiate
  <code>boost::function</code> as follows:</p>
  <pre>boost::function&lt;int (int)&gt; foo;
</pre>
  <p>The variable <code>foo</code> can now hold anything that's
  callable with an <code>int</code> as its only argument, and whose
  return type is convertible to <code>int</code>. This could be a
  function pointer, a user-defined functor, the result of a
  <code>boost::bind</code>, or what have you. Clearly, this matches
  the above definition of type erasure.</p>
  <p>The relevance of this in the context of object-oriented
  programming is that an interface can now say to the client
  programmer: "I need you to give me something that's callable as
  specified by this here function type. What it really is, I don't
  care. You can give me different things at run time. Also, you can
  change your client code so it gives me something other than it
  did before, and you won't have to recompile me." Or, referring to
  a return value rather than an argument, an interface could say:
  "I'll give you something that's callable as specified by this
  here function type. What it really is, you won't know. It could
  change at run time. I might also change it at compile time, but
  don't worry, you won't have to recompile because of that."</p>
  <p>It should be clear now that our problem with iterator types
  could be solved by a type-erasing iterator class, that is, an
  iterator that can hold concrete iterators of all manner of type,
  as long as they have a suitable commonality. An interface such as
  the one of our <code>number_cruncher</code> could then say to its
  clients: "I will give you a pair of input iterators which
  dereference to something that converts to <code>double</code>. If
  you insist on knowing, I can tell you that what you're getting is
  the result of a type erasure. But that's irrelevant to you,
  because you will never know what the real type was before the
  erasure. In fact, before the erasure, the iterator category may
  have been better than 'input.' But you won't know that, and you
  will only ever see the input iterator interface. Any change that
  I make to the actual, un-erased type of the iterator, be it at
  runtime or at compile time, will go completely unnoticed by
  you."</p>
  <p>In the second part of this article, I will discuss how type
  erasure can be implemented in C++. Specifically, I will present
  my <code>any_iterator</code>[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">2</a>], a class template that provides
  type erasure for C++ iterators.</p>
  <h1 id="part2">Implementing Type Erasure in C++, with an Emphasis
  on Iterator Type Erasure</h1>
  <h2>Implementing Type Erasure in C++: A Closer Look at
  <code>boost::any</code></h2>
  <p>Recall that Dave Abrahams and Aleksey Gurtovoy defined type
  erasure as "the process of turning a wide variety of types with a
  common interface into one type with that same interface." Now
  imagine you are designing a set of C++ classes with a common
  interface from scratch, and you want to be able to treat them as
  one type with that same interface. Talk about OO programming 101:
  you would derive your classes from a common base class. And
  that's exactly the idea behind implementing type erasure in C++.
  We would like the classes whose type we want to erase to be
  derived from a common base class. But since these classes already
  exist, and we must work non-intrusively, we can do this only
  indirectly, by first placing a wrapper class template around the
  existing classes. The wrapper class template is under our
  control, and therefore, we can derive it from a common base
  class.</p>
  <p>A good first example to illustrate all this is
  <code>boost::any</code>, which provides type erasure for the set
  of all C++ types that are copiable and destructible. A variable
  of type <code>boost::any</code> can hold objects of any such
  type. This example is extreme, but it is also extremely simple,
  because the common interface of the erased types is empty.</p>
  <p>Here is the implementation of <code>boost::any</code>,
  abbreviated to its bare essentials. The common abstract base
  class from which the wrapper class template will be derived looks
  like this:</p>
  <pre>class placeholder
{
public:
  virtual ~placeholder() {}
  virtual placeholder* clone() const=0;
};
</pre>
  <p>And this is the wrapper class template:</p>
  <pre>template&lt;typename ValueType&gt;
class holder : public placeholder
{
public:
  holder(ValueType const &amp; value) : held(value) {}
  virtual placeholder* clone() const 
  {return new holder(held);}

private:
  ValueType held;
};
</pre>
  <p>The actual type erasing class <code>any</code> is a handle
  class that holds a pointer to the abstract base class:</p>
  <pre>class any
{
public:
  any() : content(0) {}

template&lt;typename ValueType&gt;
any(ValueType const &amp; value) : content(new holder&lt;ValueType&gt;(value)) {}

any(any const &amp; other) : 
  content(other.content ? other.content-&gt;clone() : 0) {}

~any() 
{delete content;}

// Implement swap as swapping placeholder pointers, assignment
// as copy and swap.

private:
  placeholder* content;
};
</pre>
  <p>A typical use of <code>boost::any</code> is to hold objects of
  vastly different types in an STL container.</p>
  <p>Since the common interface of the types that
  <code>boost::any</code> erases is empty, an object of type
  <code>boost::any</code> isn't worth very much until one retrieves
  the held object with its original type. To this end, the real
  <code>boost::any</code> provides a query function to obtain the
  typeid of the held object, and safe casts to retrieve the held
  object. In this one respect, <code>boost::any</code> is not
  typical of type erasure in general. In those cases where the type
  erasing class actually has an interface, part of the purpose of
  the type erasure is to restrict clients to that interface. One
  should therefore not provide ways to retrieve the original
  objects with their original types.</p>
  <p>It should be clear by now how a type erasing class will handle
  the implementation of the common interface of the erased types:
  it will forward its public member functions to the abstract base
  class, where they exist as pure virtuals. The wrapper class
  template will implement these pure virtuals by forwarding them to
  its held object.</p>
  <p>As was to be expected, type erasure does not come free of
  charge. We just saw that calling a member function on a
  type-erasing object incurs the extra cost of a level of
  indirection and a virtual function call. Construction and
  destruction of such an object involves newing and deleting an
  object. The heap access can sometimes be eliminated if a small
  object optimization is employed, as is the case with the
  <code>poly</code> library[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">7</a>] (more about this very
  interesting library shortly). If you agree with me that good
  engineering is not about following dogmas but about choosing
  sensible trade-offs, then you will also agree that this
  performance overhead is not per se a problem. It is an aspect to
  be kept in mind when choosing your trade-offs.</p>
  <h2>Beyond <code>boost::any</code></h2>
  <p>In his original documentation of
  <code>boost::any</code>[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">5</a>], Kevlin Henney has pointed out
  that his <code>any</code> class can be used as a blueprint for
  more general instances of type erasure: "A similar design,
  offering more appropriate operators, can be used for a
  generalized function adaptor, any_function, a generalized
  iterator adaptor, any_iterator, and other object types that need
  uniform runtime treatment but support only compile-time template
  parameter conformance."</p>
  <p>The <code>any_function</code> class has since been implemented
  as <code>boost::function</code>. In the next few sections, I will
  discuss my attempt at the <code>any_iterator</code>[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">2</a>]. A similar, independent effort
  at C++ iterator type erasure is the Adobe Public Library's
  <code>any_iterator</code>[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">8</a>]. I will discuss the
  relationship between their work and mine later.</p>
  <p>Perhaps the most exciting recent work in the area of type
  erasure is the <code>poly</code> library by Jaakko Jarvi, Mat
  Marcus, and Sean Parent. What they do, in the best tradition of
  generic programming, is to abstract out the commonality of C++
  type erasure implementations into a generic mechanism. Their
  <code>poly</code> library is done in ConceptGCC, the fork of gcc
  that implements concepts as envisioned by the C++ Standard
  Committee. Therefore, it may be a while until their generic type
  erasure will be available to the C++ community at large.
  Nonetheless, I believe that the <code>poly</code> library will be
  of critical importance in applied C++ programming, as it will
  provide the long sought-after reconciliation between the
  object-oriented and generic programming paradigms.</p>
  <h2>Implementing Iterator Type Erasure in C++: The
  <code>any_iterator</code></h2>
  <p>Let me begin by reminding you what the original motivation for
  my <code>any_iterator</code> was: I had a number crunching class
  that provided to its clients a large number of sequences of
  numbers. Some of these sequences—the primary ones—were internally
  stored in STL containers, others—the secondary ones—were
  calculated from the primary ones on the fly by Boost iterator
  adaptors. Making clients deal with this zoo of iterator types had
  caused grief. Therefore, I wanted an iterator that was to be an
  input iterator—and an input iterator only—that would dereference
  to a <code>double</code>. This iterator was to be such that it
  could hold any one of the multitude of iterators that my class
  was exposing.</p>
  <p>It would of course be silly to go for just this special input
  iterator. Instead, I aimed for a full solution to the C++
  iterator type erasure problem. The first issue that one needs to
  address in a situation like that is the granularity of the type
  erasure. Clearly, it does not make sense to have a single
  <code>any_iterator</code> type that can hold just any old C++
  iterator.</p>
  <p>So what kind of <code>any_iterator</code> types should there
  be, and what "concrete" iterators should be assignable to them?
  In order to answer these questions it is useful to do a fast
  forward and think about the implementation of the
  <code>any_iterator</code> first. It turns out that we have our
  work cut out for us here. On the one hand, we know that the
  overall structure of our implementation will follow the standard
  type erasure technique as set forth by <code>boost::any</code>.
  On the other hand, it is clear that an iterator class that one
  writes in C++ must be Standard conforming, and the Standard
  conformance will of course be achieved by deriving from
  <code>boost::iterator_facade</code>[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">9</a>]. As usual, the devil is in the
  details, but this high-level description is pretty much all you
  need to know about the implementation of
  <code>any_iterator</code>.</p>
  <p>Now we are in a position to tackle the issue of the
  granularity of our iterator type erasure.</p>
  <h2>Determining the Granularity of the Iterator Type Erasure</h2>
  <p>The <code>boost::iterator_facade</code> class template that
  we'll be using to implement the <code>any_iterator</code> takes
  five template arguments, like this:</p>
  <pre>template&lt;
  lass Derived, // The derived iterator type being constructed
  class Value,
  class CategoryOrTraversal,
  class Reference = Value&amp;,
  class Difference = std::ptrdiff_t
&gt;
class iterator_facade;
</pre>
  <p>When we derive our <code>any_iterator</code> from this class
  template, we'll have to decide on values for the second through
  fifth template arguments. These four types make up the iterator
  traits in the sense of the Boost iterator library. This suggests
  that we should have our <code>any_iterator</code> class template
  take exactly those four template arguments. In other words, there
  will be exactly one <code>any_iterator</code> type for each set
  of iterator traits. This design is in keeping with the spirit of
  the Boost iterator library and it has worked well for us in
  practice.</p>
  <p>The other question in connection with the granularity of the
  type erasure is which "concrete" iterators should be assignable
  to an instantiation of the <code>any_iterator</code> class
  template. Technically speaking, this is the problem of correctly
  enabling and disabling the templatized converting constructor and
  assignment operator of the <code>any_iterator</code> class
  template. To make the solution that I chose plausible to you, let
  us look at an example of using the <code>any_iterator</code>.</p>
  <p>Remember that earlier, we were looking for an input iterator
  type that would dereference to a double. This iterator type was
  to be capable of holding STL iterators such as
  <code>std::vector&lt;double&gt;::const_iterator</code> and
  <code>std::list&lt;double&gt;::const_iterator</code>. It should
  also be able to hold all manner of Boost iterators such as
  transform iterators and zip iterators, as long as they are input
  iterators and dereference to something that converts to a double.
  To make the example a bit more interesting, let us assume that we
  want to expose an iterator with bidirectional traversal
  capabilities instead of just an input iterator. Given that our
  <code>any_iterator</code> class template looks like this:</p>
  <pre>template&lt;
  class Value,
  class CategoryOrTraversal,
  class Reference = Value&amp;,
  class Difference = std::ptrdiff_t
&gt;
class any_iterator;
</pre>let's try this for our number iterator:
  <pre>typedef any_iterator&lt;
  double const,
  boost::bidirectional_traversal_tag
&gt; 
number_iterator;
</pre>
  <p>Notice that I have used the bidirectional traversal tag from
  the Boost iterator library for the
  <code>CategoryOrTraversal</code> template parameter. It is
  possible to use the old-style STL iterator categories such as
  <code>std::bidirectional_iterator_tag</code> here, but you should
  prefer the new traversal tags. See the Boost iterator library
  documentation[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">10</a>] for more
  details.</p>
  <p>This will actually go a long way. The following will compile
  and work fine:</p>
  <pre>number_iterator number_it;

std::vector&lt;double&gt; number_vector(42, 43.0);
number_it = number_vector.begin();
double d = *number_it;

std::list&lt;double&gt; number_list(42, 44.0);
number_it = number_list.begin();
d = *number_it;
</pre>
  <p>However, if we try to assign to our number iterator a
  transform iterator which, upon dereferencing, multiplies by
  100.0, we run into trouble.</p>
  <pre>number_it = boost::make_transform_iterator(
  number_vector.begin(),
  boost::bind(std::multiplies&lt;double&gt;(), _1, 100)
);
</pre>
  <p>My <code>any_iterator</code>'s assignment operator is not
  enabled for this assignment, and you will get an error message
  such as:</p>
  <pre>binary '=': no operator found which takes a right-hand operand of type...
</pre>
  <p>Why is it that I disallow this? Our number iterator currently
  has a reference type of <code>double const&amp;</code>. The transform
  iterator's reference type is <code>double</code>. Dereferencing
  the number iterator is implemented by forwarding to the wrapped
  transform iterator. The conversion would work fine:
  <code>double</code> converts to <code>double const&amp;</code>. But
  the number iterator's <code>operator*</code> would be returning a
  reference to a temporary local variable. If you follow the good
  practice of treating compiler warnings as errors, you will most
  likely catch that, but I don't want to be responsible for that.
  Therefore, I don't even let you go there.</p>
  <p>The solution is easy: our choice of traits for the number
  iterator was not quite right.</p>
  <p>What we really want is this:</p>
  <pre>typedef any_iterator&lt;
  double const, // Value
  boost::bidirectional_traversal_tag,
  double const // Reference
&gt; 
number_iterator;
</pre>
  <p>Now all of the assignments above will compile and work. Note
  that the old STL-style iterator categories would not have allowed
  us to do this: in the STL, the reference type of a bidirectional
  iterator must be a reference. The new Boost iterator traversal
  tags give us more degrees of freedom in this regard.</p>
  <p>It is now also possible to start with a vector of floats, like
  this:</p>
  <pre>std::vector&lt;float&gt; float_vector(42, 43.0);
number_it = float_vector.begin();
</pre>
  <p>This would not have been allowed either before, when the
  <code>any_iterator</code>'s reference type was <code>double
  const&amp;</code> instead of <code>double const</code>. The reason is
  that somewhere deep inside of <code>operator*</code>, there was a
  conversion from <code>float const&amp;</code> to <code>double
  const&amp;</code>, which results in the creation of a temporary. The
  <code>any_iterator</code>'s <code>operator*</code> would have
  returned a reference to that temporary. So the bad news is that
  these references to local temporaries can creep up on you in
  unexpected ways. The good news is that my
  <code>any_iterator</code> will catch these situations for you and
  disallow the respective assignments and copies.</p>
  <p>It turns out that the exact rules by which an
  <code>any_iterator</code> instantiation decides which iterator
  types to accept for wrapping are quite subtle. But before we go
  into the details, let me point out that in practice, there is
  very little need to study these rules. One is not very likely to
  make mistakes in this respect. For example, it is clear that an
  <code>any_iterator</code> like our <code>number_iterator</code>,
  having bidirectional traversal category, will not accept
  something that's a forward iterator only, like an iterator into a
  singly linked list. That would not make sense. Similarly, our
  <code>number_iterator</code> would not accept anything that
  dereferences to something that does not convert to a
  <code>double</code>. There is no way for that to be meaningful.
  So really, using the <code>any_iterator</code> is just as easy as
  it looks in the examples above. But for completeness' sake, and
  for the fun of it, let us study the rules anyway.</p>
  <p>Suppose that <code>some_any_iterator</code> is an
  instantiation of the <code>any_iterator</code> class template
  with value type, traversal tag, reference type, and difference
  type equal to <code>AnyItValue</code>,
  <code>AnyItTraversal</code>, <code>AnyItReference</code>, and
  <code>AnyItDifference</code>, respectively. Assume further that
  <code>some_iterator</code> is an iterator type with value type,
  traversal tag, reference type, and difference type equal to
  <code>ItValue</code>, <code>ItTraversal</code>,
  <code>ItReference</code>, and <code>ItDifference</code>,
  respectively. Then a variable of type
  <code>some_any_iterator</code> will accept an object of type
  <code>some_iterator</code> if and only if the following four
  conditions are met:</p>
  <ol>
    <li><code>ItValue</code> converts to
    <code>AnyItValue</code>.<br>
    &nbsp;</li>
    <li><code>ItTraversal</code> and <code>AnyItTraversal</code>
    are equal, or the former is derived from the latter. This means
    that <code>some_iterator</code>'s traversal category is equal
    to or better than that of <code>some_any_iterator</code>.<br>
    &nbsp;</li>
    <li>The following are all true:<br>
      &nbsp;
      <ul>
        <li><code>ItReference</code> converts to
        <code>AnyItReference</code>.<br>
        &nbsp;</li>
        <li>If <code>AnyItReference</code> is a reference, then so
        is <code>ItReference</code>.<br>
        &nbsp;</li>
        <li>If <code>AnyItReference</code> and
        <code>ItReference</code> are both references, then the
        following is true: after stripping const qualifiers and
        references from <code>AnyItReference</code> and
        <code>ItReference</code>, the two are either the same, or
        the former is a base class of the latter.<br>
        &nbsp;</li>
      </ul>The second and third of the three conditions above
      ensure that no situation is allowed where
      <code>some_any_iterator</code>'s <code>operator*</code> would
      return a reference to a temporary.<br>
      &nbsp;
    </li>
    <li>If <code>some_any_iterator</code>'s traversal category is
    random access, then <code>ItDifference</code> and
    <code>AnyItDifference</code> are convertible to each other both
    ways. Here, we need convertibility in both directions because
    the difference type occurs as an argument type as well as a
    result type of iterator operators.</li>
  </ol>
  <p>This settles the issue of the granularity of our iterator type
  erasure. The only thing that remains to be discussed is
  convertibility between different <code>any_iterator</code>
  types.</p>
  <h2>Conversion between Different <code>any_iterator</code>
  Types</h2>
  <p>Instantiations of the <code>any_iterator</code> class template
  are Standard conforming iterators. Therefore, according to what
  we have so far, it would be possible to assign an object of one
  <code>any_iterator</code> type to a variable of another
  <code>any_iterator</code> type, as long as the traits of the two
  <code>any_iterator</code> types are compatible for type
  erasure:</p>
  <pre>std::vector&lt;double&gt; vect;
std::vector&lt;double&gt;::iterator vit;
any_iterator&lt;double, std::random_access_iterator_tag&gt; rit;
rit = vit;

any_iterator&lt;double, std::forward_iterator_tag&gt; fit;
fit = rit;
</pre>
  <p>The iterator <code>fit</code> now holds a copy of
  <code>rit</code>, which in turn holds the concrete vector
  iterator <code>vit</code>. All operations will go through two
  levels of indirection. It would certainly be a legitimate design
  decision to just leave it to that and never think another thing
  about it. However, it bothered me that clients could end up with
  nesting levels greater than 1 and perhaps not even be aware of
  it. Therefore, I made it so that an assignment or construction of
  one <code>any_iterator</code> from another is possible only if
  the two are of the exact same type. Instead, I added a few
  conversion operators which behave nicely, copying the wrapped
  iterator rather than increasing the nesting depth. The upside of
  this is that now you know that your nesting depth will never be
  greater than 1, no matter what you do. The downside is that the
  rules for the new conversions end up being a bit more restrictive
  than the rules for assignment to an <code>any_iterator</code>.
  Here's how it works:</p>
  <p>Let <code>ait_source</code> and <code>ait_target</code> be two
  different instantiations of the <code>any_iterator</code> class
  template. Then there is a conversion from <code>ait_source</code>
  to <code>ait_target</code> if and only if either:</p>
  <ul>
    <li>The traversal category of <code>ait_source</code> is better
    than or equal to the traversal category of
    <code>ait_target</code>, and all other iterator traits are
    exactly the same,</li>
  </ul>or
  <ul>
    <li><code>ait_target</code> is a const iterator version of
    <code>ait_source</code>.</li>
  </ul>
  <p>The deeper reason why I have to require the value types,
  reference types, and difference types to be equal is that in C++,
  convertibility is not transitive: If <code>T1</code> converts to
  <code>T2</code> and <code>T2</code> converts to <code>T3</code>,
  it does not follow that <code>T1</code> converts to
  <code>T3</code>. Therefore, if I were to require only that the
  value type of <code>ait_source</code> convert to the value type
  of <code>ait_target</code>, the wrapped iterator of an
  <code>ait_source</code> object might not be suitable for wrapping
  by an <code>ait_target</code> object.</p>
  <h2>Mundane Uses of the <code>any_iterator</code></h2>
  <p>The <code>any_iterator</code> was originally invented for the
  purpose of alleviating problems that arise when the OO and
  generic programming paradigms coexist. I have since found
  numerous more mundane applications in small, everyday programming
  tasks. Here's an example.</p>
  <p>I recently had to write a small piece of code that iterated
  over a vector of things and did some processing with each
  element. Moreover, there was a runtime condition that specified
  whether ordinary iteration or reverse iteration was to be used.
  Needless to say, I wasn't going to deal with the direction of the
  iteration myself. That's the whole point of having iterators and
  reverse iterators. Therefore, my code was going to look something
  like this:</p>
  <pre>// some_vector is an STL vector of type some_vector_type
if(!reverseIteration)
{
  some_vector_type::iterator begin = some_vector.begin();
  some_vector_type::iterator end = some_vector.end();
  // Do what needs to be done from begin to end
 }
else
{
  some_vector_type::reverse_iterator begin = some_vector.rbegin();
  some_vector_type::reverse_iterator end = some_vector.rend();
  // Do what needs to be done from begin to end
}
</pre>
  <p>The annoying part is that now, the "Do what needs to be done"
  part operates on iterators of unrelated types. Short of the
  abomination of duplicating the code, that forces me to use a
  templatized function to do what needs to be done. In many cases,
  that may be just fine and dandy. Still, I must say that I hate
  this kind of situation with a vengeance. The fact that the
  ordinary iterator and the reverse iterator have unrelated types,
  which never felt very natural in the first place, deprives me of
  the freedom to choose my function nesting level the way I see
  fit.</p>
  <p>Iterator type erasure saves. Below is how you can use an
  <code>any_iterator</code> if you do not wish to use a function
  template to implement the "Do what needs to be done" part. Here,
  you can also see a little convenience metafunction called
  <code>make_any_iterator_type at work</code>. This metafunction,
  which comes with my <code>any_iterator</code>, takes an iterator
  type as its argument and produces an instantiation of the
  <code>any_iterator</code> class template with the same iterator
  traits. In other words, it allows you to create an
  <code>any_iterator</code> type "by example."</p>
  <pre>typedef 
make_any_iterator_type&lt;
  some_vector_type::iterator
&gt;::type local_iter_type;

local_iter_type begin;
local_iter_type end;
if(!reverseIteration)
{
  begin = some_vector.begin();
  end = some_vector.end();
}
else
{
  begin = some_vector.rbegin();
  end = some_vector.rend();
}
// Do what needs to be done from begin to end
</pre>
  <p>Regardless of how often I am going to prefer the second
  solution over the first, I find it rather comforting to have the
  choice available to me.</p>
  <h2><a name="section_12" id="section_12">Other Attempts at C++
  Iterator Type Erasure</a></h2>
  <p>As I mentioned earlier, there is an <code>any_iterator</code>
  class template in the Adobe Public Library, which was developed
  independently from my <code>any_iterator</code>. It is clear from
  the documentation that their effort is very similar to mine.
  However, they currently label their work as "an experiment." This
  is probably the reason why the documentation is not very
  specific. Therefore, I am not sure how exactly our efforts relate
  when it comes to the more subtle design decisions. It would of
  course be possible to find out more by studying their source code
  or playing with their class. However, I am reluctant to spend
  that kind of time and effort as long as their work is considered
  experimental and may therefore change anytime.</p>
  <p>My guess would be that the design decisions that the Adobe
  Library people made are very similar to mine and possibly better.
  For now, my <code>any_iterator</code> gives you the advantage of
  being well-documented and being usable by just downloading a few
  header files, rather than having to install a third party
  library. But if and when the Adobe people upgrade their work from
  "experimental" to "officially supported," you're probably better
  off going with something that has the full support of a dedicated
  group of very smart people.</p>
  <h2>Outlook: C++ Concepts and the <code>any_iterator</code></h2>
  <p>The implementation of class templates such as
  <code>any_iterator</code> will benefit enormously from the
  introduction of <em>concepts</em> into the C++ Standard. If you
  are unfamiliar with this proposed language addition, a good place
  to start is the article on the <code>poly</code> library by
  Jaakko Jarvi, Mat Marcus, and Sean Parent. Section 2 of the
  article is a lucid and succinct introduction to concepts. The
  <code>poly</code> library that is described in the rest of their
  paper is in fact a great case study in applying concepts. The
  paper also has an excellent list of references on C++
  concepts.</p>
  <p>Please read on only if you are interested in how C++ concepts
  will replace and improve current workarounds that are based on
  the SFINAE principle. If you do not want to dig that deep—and
  there is nothing wrong with that attitude—skip right ahead to the
  <em>acknowledgements</em>, and you are done with reading this
  article!</p>
  <p>Of all the additions to the C++ language that are currently in
  the pipeline, C++ concepts is probably the most important and
  far-reaching one. Concepts will add an enormous amount of
  structure, clarity, expressiveness, and convenience to generic
  programming in C++. The <code>any_iterator</code> is special in
  this respect because it is a rare example of a class template
  where C++ concepts will do more than just simplify and improve
  the code. There is actually something fairly important that I
  cannot do right now, but will be able to do with concepts. In
  other words, the point that I will be making in the rest of this
  article is this: C++ concepts are not only a better and more
  convenient alternative to the workarounds that we currently use.
  Rather, some of today's workarounds are positively broken and
  <em>we need concepts to fix them.</em></p>
  <p>We saw earlier that one of the main issues with the
  <code>any_iterator</code> was to enable and disable the
  converting constructor and assignment operator in such a way that
  only certain compatible "concrete" iterators are allowed for
  construction and assignment to the <code>any_iterator</code>. In
  today's C++, this is achieved with
  <code>boost::enable_if</code>[<a href="https://www.artima.com/cppsource/type_erasure2.html#notes">11</a>], which I will assume you are
  familiar with. My <code>any_iterator</code>'s assignment
  operator, for example, currently looks like this:</p>
  <pre>template&lt;class WrappedIterator&gt;
typename boost::enable_if&lt;
  detail::is_iterator_type_erasure_compatible&lt;
    WrappedIterator, 
    any_iterator
  &gt;,
  any_iterator
&gt;::type &amp;
operator=(WrappedIterator const &amp; wrapped_iterator)
{
  any_iterator tmp(wrapped_iterator);
  swap(tmp);
  return *this;
}
</pre>
  <p>Here, <code>is_iterator_type_erasure_compatible</code> is a
  fairly complex metafunction that implements the rules for
  assigning "concrete" iterator types to <code>any_iterator</code>
  types. Thanks to <code>boost:enable_if</code>, this is actually a
  rather elegant and readable solution. Moreover, the error message
  that you get when you try to assign an iterator of incompatible
  type to an <code>any_iterator</code> is not one of those cryptic,
  endlessly nested template error messages. Your compiler will
  simply say something like:</p>
  <pre>binary '=': no operator found which takes a right-hand operand of
type...
</pre>
  <p>But the fact remains that this is a workaround. I had to
  ponder over a lot of those awful template error messages until I
  had it all working on each of the three compilers that I
  currently support. In the shiny new world of concepts, I will be
  able to express my condition
  <code>is_iterator_type_erasure_compatible</code> directly in the
  language as what it is, namely, a property of types. I will be
  defining a concept that will most likely look something like
  this:</p>
  <pre>auto concept IteratorTypeErasureCompatible&lt;
  typename SourceIterator,
  typename TargetIterator
&gt; : Iterator(SourceIterator) &amp;&amp; Iterator(TargetIterator)
{
  requires 
  Convertible(
    SourceIterator::value_type, 
    TargetIterator::value_type
  ) 
  &amp;&amp;
  Convertible(
    SourceIterator::reference_type, 
    TargetIterator::reference_type
  ) 
  &amp;&amp;
  (! Reference(TargetIterator::reference_type) || 
     Reference(SourceIterator::reference_type)
  ) 
  &amp;&amp;
  // ...
  
};
</pre>
  <p>The <code>any_iterator</code>'s assignment operator will then
  look like this:</p>
  <pre>template&lt;class WrappedIterator&gt;
requires IteratorTypeErasureCompatible&lt;
  WrappedIterator, 
  any_iterator
&gt;
any_iterator&amp; operator=(WrappedIterator const &amp; wrapped_iterator)
{
  any_iterator tmp(wrapped_iterator);
  swap(tmp);
  return *this;
}
</pre>
  <p>Rather obviously, this is an enormous step forward from the
  workaround using SFINAE, traits, and template metaprogramming.
  Moreover, the error message for a bad assignment is going to
  improve a bit. It will now give a reason for the failure to
  assign, namely, the violation of the concept
  <code>IteratorTypeErasureCompatible</code>.</p>
  <p>Things get a lot more interesting if we try to do the same
  thing for the converting constructor from wrapped iterator. After
  looking at the assignment operator, you would expect that
  converting constructor to look something like this:</p>
  <pre>template&lt;class WrappedIterator&gt;
any_iterator(
  WrappedIterator const &amp; wrapped_iterator,
  typename boost::enable_if&lt;
    detail::is_iterator_type_erasure_compatible&lt;
      WrappedIterator, 
      any_iterator
    &gt;
  &gt;::type* dummy = NULL 
)
{
  // construct an any_iterator that wraps wrapped_iterator
}
</pre>
  <p>There is nothing wrong with that code as it stands. And yet,
  under some Standard-conforming compilers, this sets into motion a
  long, circuitous chain of events at the end of which we'll find
  desaster.</p>
  <p>Suppose that with the above definition of the converting
  constructor, we try to construct an <code>any_iterator</code>
  from something that is not even an iterator, like an STL pair of
  two integers:</p>
  <pre>std::pair&lt;int, int&gt; p(42, 42);

typedef any_iterator&lt;
  double, 
  std::random_access_iterator_tag
&gt; any_ra_iterator;

any_ra_iterator ra_it(p);
</pre>
  <p>Needless to say, we want this construction to fail, and we're
  hoping for a nice, simple error message from the compiler. So
  what's going to happen? As the compiler encounters the
  <code>boost::enable_if</code> in the constructor, it will
  evaluate the metafunction call:</p>
  <pre>is_iterator_type_erasure_compatible&lt;
  std::pair&lt;int, int&gt;, 
  any_ra_iterator
&gt;
</pre>
  <p>I never showed you the details of
  <code>is_iterator_type_erasure_compatible</code>, but we know
  that it is the conjunction of a bunch of conditions such as "the
  value type of the first argument converts to the value type of
  the second argument." Therefore, one of the things that the
  compiler encounters deep, deep down in this metafunction
  evaluation is this:</p>
  <pre>std::iterator_traits&lt;std::pair&lt;int, int&gt; &gt;::value_type
</pre>
  <p>This template instantiation will fail, because STL pairs are
  not iterators and thus have no value type. So, overall,
  substituting the type <code>std::pair&lt;int, int&gt;</code> for
  the template parameter <code>WrappedIterator</code> of our
  <code>any_iterator</code>'s converting constructor failed. That's
  not an error, says SFINAE, and hence, this constructor just isn't
  there. We would expect a one-line error error message like:</p>
  <pre>error: cannot convert from std::pair&lt;_Ty1,_Ty2&gt; to <code>any_iterator</code>&lt;...
</pre>
  <p>Under some compilers, that's exactly what happens. Other
  compilers will barf up a pile of horrible template errors at the
  center of which lies this:</p>
  <pre>error : 'value_type' : is not a member of 'std::pair&lt;_Ty1,_Ty2&gt;' 
with _Ty1 = ...
</pre>
  <p>The reason is that the version of the SFINAE principle that
  the Standard requires is, in point of fact, rather lame. SFINAE
  is required to kick in only if the substitution failure occurs at
  the very top of the template instantiation stack. In our case,
  the substitution failure is way down on the stack. Some compilers
  voluntarily apply SFINAE in this case as well, but nobody is
  required to do so.</p>
  <p>Ok, so what kind of a problem have we seen so far? Almost none
  at all. The only bad thing is that when we try to construct an
  <code>any_iterator</code> from something that is not even an
  iterator in the first place, then some compilers give us an ugly
  error message instead of a nice one. Big deal. Ugly error
  messages abound in today's C++ programming with templates.</p>
  <p>Everything would be quite alright if it weren't, of all
  things, a converting constructor that barfs up the ugly error
  message instead of politely disabling itself. Consider what
  happens if we ask whether <code>std::pair&lt;int, int&gt;</code>
  is convertible to the <code>any_iterator</code>:</p>
  <pre>typedef any_iterator&lt;
  double, 
  std::random_access_iterator_tag
&gt; any_ra_iterator;

bool b = boost::is_convertible&lt;
  std::pair&lt;int, int&gt;, 
  any_ra_iterator
&gt;::value;
</pre>
  <p>One of the things that the metafunction
  <code>boost::is_convertible</code> will do is to look for a
  converting constructor of <code>any_ra_iterator</code> that takes
  an <code>std::pair&lt;int, int&gt;</code> as its argument. In
  doing so, it will encounter the compile error that we discussed
  earlier. Therefore, the code above will not compile.</p>
  <p>Now that's really bad. For a while, I tried to kid myself into
  thinking that one could live with that, but no. A type which can
  cause a compile error when it is used as the second argument to
  <code>boost::is_convertible</code> is evil. In particular, if a
  class has a non-explicit, templatized converting constructor,
  then the mere act of substituting for the template argument must
  not cause a compile error. The reason why this principle is
  important is this: if a class violates the principle, then the
  compiler can encounter an error while it is building a function
  overload set. Even though the offending constructor may end up
  not being used in the situation for which the overload set is
  built, just creating the overload set causes a compile error.
  That is pure evil if I ever saw it. In fact, this is the exact
  reason why the SFINAE principle exists in the first place.</p>
  <p>My problem here is that the substitution failure occurs deep
  down on the template instantiation stack, where the SFINAE
  principle as required by the Standard does not apply. It is not
  possible to fix things so that the failure occurs at the top of
  the stack. To do that, I would need a metafunction
  <code>is_iterator</code>, or <code>has_iterator_traits</code>, or
  some such thing. Such a metafunction does not exist, and it is
  impossible to write one (try it).</p>
  <p>Once we'll have concepts in C++, all this is going to go away.
  Just take one look at the concept
  <code>IteratorTypeErasureCompatible</code> that I outlined
  earlier. The very first thing that it requires is that
  <code>WrappedIterator</code> is an iterator at all. If that's not
  the case, the concept is not modeled, and all is well.</p>
  <p>For now, I could see no alternative but make the constructor
  that constructs an <code>any_iterator</code> from a wrapped
  iterator explicit and replace the <code>enable_if</code> with a
  static assert. I really hated to do that, but for the life of me,
  I can't see any other way out until there will be concepts in
  C++. What this means is that for now, a wrapped iterator never
  converts to an <code>any_iterator</code>. There are only two ways
  to get a "concrete" iterator object into an
  <code>any_iterator</code> variable: either by ordinary
  assignment, as in:</p>
  <pre>std::vector&lt;int&gt; vect;
any_iterator&lt;int, std::forward_iterator_tag&gt; ait;
ait = vect.begin();
</pre>
  <p>or using <em>explicit</em> construction:</p>
  <pre>std::vector&lt;int&gt;;
any_iterator&lt;
  int, 
  std::forward_iterator_tag
&gt; ait_1(vect.begin()); // fine

any_iterator&lt;
  int, 
  std::forward_iterator_tag
&gt; ait_2 = vect.begin(); // error, requires non-explicit ctor
</pre>
  <p>Please, C++ Standard committee and compiler vendors, give us
  concepts! We're in a lot of pain here!</p>
  <h1>Acknowledgements</h1>
  <p>I am greatly indebted to Dave Abrahams, Christopher Baus, Fred
  Bertsch, Don Harriman, and Thomas Witt, who have helped me in
  more ways than I can recall. All remaining errors and
  inadequacies, both in this article and in my
  <code>any_iterator</code> implementation, are mine.</p>
<!-- TOP OF SHARE YOUR OPINION -->
  <h1>Share your opinion</h1>
  <p>Have an opinion about Tension between Object-Oriented
  Programming and Generic Programming?</p>Discuss this article in
  the Articles Forum topic, <a href="http://www.artima.com/forums/flat.jsp?forum=226&amp;thread=216972">
  On the Tension between Object-Oriented and Generic Programming in
  C++, and What Type Erasure Can Do about It</a>.
<!-- BOTTOM OF SHARE YOUR OPINION -->
  <h1>References</h1><a name="notes" id="notes"></a>
  <p>[1] Bjarne Stroustrup's definition of C++<br>
  <a href="http://www.research.att.com/~bs/glossary.html#GC++">http://www.research.att.com/~bs/glossary.html#GC++</a></p>
  <p>[2] Download my <code>any_iterator</code> (with documentation
  and regression tests)<br>
  <a href="http://thbecker.net/free_software_utilities/type_erasure_for_cpp_iterators/IteratorTypeErasure.zip">
  http://thbecker.net/free_software_utilities/type_erasure_for_cpp_iterators/IteratorTypeErasure.zip</a></p>
  <p>[3] An interview with Alexander Stepanov<br>
  <a href="http://www.stlport.org/resources/StepanovUSA.html">http://www.stlport.org/resources/StepanovUSA.html</a></p>
  <p>[4] Dave Abrahams' and Aleksey Gurtovoy's book on C++ template
  metaprogramming<br>
  <a href="http://boost-consulting.com/mplbook/">http://boost-consulting.com/mplbook/</a></p>
  <p>[5] <code>boost::any</code><br>
  <a href="http://www.boost.org/doc/html/any.html">http://www.boost.org/doc/html/any.html</a></p>
  <p>[6] <code>boost::function</code><br>
  <a href="http://www.boost.org/doc/html/function.html">http://www.boost.org/doc/html/function.html"&gt;</a></p>
  <p>[7] Article on the <code>poly</code> librar by Jaakko Jarvi,
  Mat Marcus, and Sean Parent<br>
  <a href="http://homepages.fh-regensburg.de/~mpool/mpool07/proceedings/5.pdf">
  http://homepages.fh-regensburg.de/~mpool/mpool07/proceedings/5.pdf</a></p>
  <p>[8] Adobe Public Library's any_iterator<br>
  <a href="http://opensource.adobe.com/classadobe_1_1any__iterator.html">http://opensource.adobe.com/classadobe_1_1any__iterator.html"&gt;</a></p>
  <p>[9] <code>boost::iterator_facade</code><br>
  <a href="http://www.boost.org/libs/iterator/doc/index.html#iterator-facade-and-adaptor">
  http://www.boost.org/libs/iterator/doc/index.html#iterator-facade-and-adaptor</a></p>
  <p>[10] Boost new style iterators<br>
  <a href="http://www.boost.org/libs/iterator/doc/index.html#new-style-iterators">
  http://www.boost.org/libs/iterator/doc/index.html#new-style-iterators</a></p>
  <p>[11] <code>boost::enable_if</code><br>
  <a href="http://www.boost.org/libs/utility/enable_if.html">http://www.boost.org/libs/utility/enable_if.html&gt;</a></p>
<!-- TOP OF ABOUT THE AUTHOR -->
  <h1>About the Author</h1>
  <p>Thomas Becker is a scientific software engineer at Zephyr
  Associates, Inc. in Lake Tahoe, Nevada, where he works on
  financial analytics software. He is a former columnist for the
  now defunct C/C++ Users Journal. You can reach him at <em>thomas
  at styleadvisor dot com</em>. To find out more about Thomas,
  visit his homepage at <a href="http://thbecker.net/">thbecker.net</a></p>
<!-- BOTTOM OF ABOUT THE AUTHOR -->

<br clear="all">
<p>
</p><center>
<div class="sc">
<a href="https://www.artima.com/cppsource/index.html">The C++ Source</a>&nbsp;| 
<a href="https://www.artima.com/groups/group.jsp?group=cpp">C++ Community News</a>&nbsp;| 
<a href="https://www.artima.com/forums/flat.jsp?forum=226&amp;thread=216972">Discuss</a>&nbsp;| 
<a href="mailto:?subject=On%20the%20Tension%20Between%20Object-Oriented%20and%20Generic%20Programming%20in%20C++&amp;body=%20%0AOn%20the%20Tension%20Between%20Object-Oriented%20and%20Generic%20Programming%20in%20C++%20%0Aand%20What%20Type%20Erasure%20Can%20Do%20About%20It%20%0Aby%20Thomas%20Becker%20%0A%0Ahttps://www.artima.com/cppsource/type_erasure.html">Email</a>&nbsp;| 
Previous&nbsp;| 
Next
</div>
</center>
</div>
<hr width="100%">
<table width="50%" align="center">
<tbody><tr>
<td>
<div class="horizontaltextadbox">
<div class="adheadline">Sponsored Links</div>
<div id="sponsoredlinks">
</div>
</div>
</td>
</tr>
</tbody></table>
<hr width="100%">
<center>
<script type="text/javascript"><!--
google_ad_client = "pub-3911176865765226";
google_alternate_color = "ffffff";
google_ad_width = 728;
google_ad_height = 15;
google_ad_format = "728x15_0ads_al";
google_ad_channel = "";
google_color_border = "ffffff";
google_color_bg = "FFFFFF";
google_color_link = "003090";
google_color_text = "000000";
google_color_url = "666666";
//--></script>
<script type="text/javascript" src="./On the Tension Between Object-Oriented and Generic Programming in C++_files/f.txt">
</script>
<br>
<br>
<!-- SiteSearch Google -->
<form method="get" action="https://www.google.com/custom">
<table border="0" bgcolor="#ffffff">
<tbody><tr><td nowrap="nowrap" valign="top" align="left" height="32">
<a href="https://www.google.com/">
<img src="./On the Tension Between Object-Oriented and Generic Programming in C++_files/Logo_25wht.gif" border="0" alt="Google"></a>
</td>
<td nowrap="nowrap">
<input type="hidden" name="domains" value="Artima.com">
<input type="text" name="q" size="31" maxlength="255" value="">
<input type="submit" name="sa" value="Search">
</td></tr>
<tr>
<td>&nbsp;</td>
<td nowrap="nowrap">
<font size="-1" color="#000000">
<input type="radio" name="sitesearch" value=""> Web
<input type="radio" name="sitesearch" value="Artima.com" checked="checked">Artima.com
</font>&nbsp;&nbsp;
<input type="hidden" name="client" value="pub-3911176865765226">
<input type="hidden" name="forid" value="1">
<input type="hidden" name="ie" value="ISO-8859-1">
<input type="hidden" name="oe" value="ISO-8859-1">
<input type="hidden" name="cof" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;LH:50;LW:150;L:https://www.artima.com/images/artima150.gif;S:https://www.artima.com;FORID:1;">
<input type="hidden" name="hl" value="en">
</td></tr></tbody></table>
</form>
<!-- SiteSearch Google -->
</center>
<div class="sp">
<div style="text-align: center">
<a href="https://www.artima.com/copyright.html">Copyright</a> © 1996-2019 Artima, Inc. All Rights Reserved. - <a href="https://www.artima.com/privacy.html">Privacy Policy</a> - <a href="https://www.artima.com/termsofuse.html">Terms of Use</a>
</div>
</div>
<br>
<script language="JavaScript" type="text/javascript">
<!--
function initBannerVarForZone(zone) {
        initBannerVarForZoneWithScript(zone, 'adjs_modified');
}

function initBannerVarForZoneWithScript(zone, phpScript) {

        if (!document.phpAds_used) document.phpAds_used = ',';
        phpAds_random = new String (Math.random());
        phpAds_random = phpAds_random.substring(2,11);

        var nextScriptSrc = 'https://www.artima.com/zcr/' + phpScript + '.php?n=' +
                phpAds_random  +
                '&amp;what=zone:' + zone + '&amp;target=_top&amp;block=1&amp;blockcampaign=1' +
                '&amp;exclude=' + document.phpAds_used;

        document.write("<script language='JavaScript' type='text/javascript' src='");
        document.write(nextScriptSrc);
        document.write("'><\/script>");

}

function replaceDiv(divID) {
        document.getElementById(divID).innerHTML = phpadsbanner;
}
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZone(1);
-->
</script>

<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('topbanner');
-->
</script>
<script language="JavaScript" type="text/javascript">
<!--
initBannerVarForZoneWithScript(4, 'textman');
-->
</script>

<script language="JavaScript" type="text/javascript">
<!--
replaceDiv('sponsoredlinks');
-->
</script>


</body></html>