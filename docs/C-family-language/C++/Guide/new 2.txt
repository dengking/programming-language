#1
dispatch：
polymorphism是一种dispatch
C++在这方面的提升：
Compile Time if - Since C++17：https://www.bfilipek.com/2016/02/notes-on-c-sfinae.html#compile-time-if-since-c17
https://www.bfilipek.com/2018/03/ifconstexpr.html

#2


需要梳理清楚overload resolution、template function之间的关系；substitution和overload resolution的发生顺序。






#4
tag dispatch的优势

iterator library是一个非常好的example，strtk也是一个非常好的example


#5
overload resolution

在下面的文章中，谈及了overload resolution：
https://en.cppreference.com/w/cpp/language/sfinae
This rule applies during overload resolution of function templates: When substituting the explicitly specified or deduced type for the template parameter fails, the specialization is discarded from the overload set instead of causing a compile error.


https://www.bfilipek.com/2016/02/notes-on-c-sfinae.html#overload-resolution

When the compiler tries to compile a function call (simplified):

Perform a name lookup
For function templates the template argument values are deduced from the types of the actual arguments passed into the function.
All occurrences of the template parameter (in the return type and parameters types) are substituted with those deduced types.
When this process leads to invalid type (like int::internalType) the particular function is removed from the overload resolution set. (SFINAE)
At the end, we have a list of viable functions that can be used for the specific call. If this set is empty, then the compilation fails. If more than one function is chosen, we have an ambiguity. In general, the candidate function, whose parameters match the arguments most closely is the one that is called.

https://akrzemi1.wordpress.com/2015/11/19/overload-resolution/

http://foonathan.github.io/blog/2015/11/30/overload-resolution-4.html


#6

刚刚阅读cppreference中关于iterator operation的实现的样例代码，链接如下：
https://en.cppreference.com/w/cpp/iterator/next
https://en.cppreference.com/w/cpp/iterator/distance
https://en.cppreference.com/w/cpp/iterator/advance
https://en.cppreference.com/w/cpp/iterator/prev

可以看到，无论是first version，还是second version，都充分运用了trait，显然trait是一种抽象。

尤其是distance 的 Second version，它让我想到了我之前实现的api框架；我的实现思路与它的实现思路非常类似，我也是基于tag dispatch的，将api分为多类，每类一个tag，然后基于tag进行dispatch。tag是通过trait而获取的

显然，在实际开发中，需要结合多种idiom才能够充分发挥C++的威力；正如上述例子，结合了trait、tag dispatch；

