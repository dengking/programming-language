# [async-profiler](https://github.com/async-profiler)/**[async-profiler](https://github.com/async-profiler/async-profiler)**

Unlike traditional Java profilers, async-profiler monitors **non-Java threads** (e.g., GC and JIT compiler threads) and shows native and kernel frames in stack traces.

What can be profiled:

- CPU time
- Allocations in Java Heap
- Native memory allocations and **leaks**
- Contended locks
- Hardware and software performance counters like **cache misses**, page faults, context switches
- and [more](https://github.com/async-profiler/async-profiler/blob/master/docs/ProfilingModes.md).
- 

## [GettingStarted](https://github.com/async-profiler/async-profiler/blob/master/docs/GettingStarted.md)

async-profiler works in the context of the target Java application, i.e. it runs as an **agent** in the process being profiled.

> NOTE: agent如何理解? 显然async-profiler就是这个agent

## [Profiling modes](https://github.com/async-profiler/async-profiler/blob/master/docs/ProfilingModes.md)

> NOTE: 作者将 [async-profiler](https://github.com/async-profiler/async-profiler)能够profile的内容称之为 profiling mode

Besides CPU time, **async-profiler** provides various other **profiling modes** such as `Allocation`, `Wall Clock`, `Java Method` and even a `Multiple Events` profiling mode.

### CPU profiling

In this mode, profiler collects stack trace samples that include **Java** methods, **native** calls, **JVM** code and **kernel** functions.

The general approach is receiving **call stacks** generated by `perf_events` and matching them up with call stacks generated by `AsyncGetCallTrace`, in order to produce an accurate profile of both Java and native code. Additionally, async-profiler provides a workaround to recover stack traces in some [corner cases](https://bugs.openjdk.java.net/browse/JDK-8178287) where `AsyncGetCallTrace` fails.

> NOTE:
> 
> `AsyncGetCallTrace`是jvm中异步获取stack trace的API，参见:
> 
> [JEP 435: Asynchronous Stack Trace VM API](https://openjdk.org/jeps/435)
> 
> [github AsyncGetCallTrace replacement #795](https://github.com/async-profiler/async-profiler/issues/795) 
> 
> 通过 [github AsyncGetCallTrace replacement #795](https://github.com/async-profiler/async-profiler/issues/795) 中的内容可知: `AsyncGetCallTrace`是可以被取代的

This approach has the following advantages compared to using `perf_events` directly with a Java agent that translates addresses to Java method names:

- Does not require `-XX:+PreserveFramePointer`, which introduces performance overhead that can be sometimes as high as 10%.
- Does not require starting JVM with an agent for translating Java code addresses to method names.
- Displays interpreter frames.
- Does not produce large intermediate files (perf.data) for further processing in user space scripts.

If you wish to resolve frames within `libjvm`, the [debug symbols](https://github.com/async-profiler/async-profiler/blob/master/docs/ProfilingModes.md#installing-debug-symbols) are required.

### Java method profiling