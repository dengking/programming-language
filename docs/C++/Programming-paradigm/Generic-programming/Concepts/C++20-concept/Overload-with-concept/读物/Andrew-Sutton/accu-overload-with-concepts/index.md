# accu [OVERLOADING WITH CONCEPTS](https://accu.org/journals/overload/24/136/sutton_2316/)

This is the third, and long overdue, article in my series on C++ concepts. The first two articles focused on how concepts are used to constrain generic algorithms [ [Sutton15 ](https://accu.org/journals/overload/24/136/sutton_2316/#[Sutton15])] and how concepts are defined [ [Sutton16 ](https://accu.org/journals/overload/24/136/sutton_2316/#[Sutton16])]. This article describes a sometimes overlooked, frequently misunderstood, and yet extraordinarily powerful feature of concepts: their role in function overloading. Concepts are useful for more than just improving error messages and precise specification of interfaces. They also increase expressiveness. Concepts can be used to shorten code, make it more generic, and increase performance.



Finally, since concepts was not accepted into C++17, I have seen an increase in online content promoting concept emulation techniques over language support and even claims that expression SFINAE, constexpr if, `static_assert `, and clever metaprogramming techniques are sufficient for our needs. That’s analogous to claiming that given `if `and `goto `, we don’t need `while `, `for `, and range- `for `. Yes, it’s logically correct, but in both cases we drag down the level of abstraction to specifying how things are to be done, rather than what should be done. The result is more work for the programmer, more bugs, and fewer optimization opportunities. C++ is not meant to be just an assembly language for template metaprogramming. Concepts allows us to raise the level of programming and simplify the code, without adding run-time overhead.