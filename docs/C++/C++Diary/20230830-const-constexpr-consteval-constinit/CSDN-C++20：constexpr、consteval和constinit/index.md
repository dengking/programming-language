# [CSDN-C++20：constexpr、consteval和constinit](https://blog.csdn.net/liuguang841118/article/details/127754252)




## 缘由

C++之父Bjarne Stroustrup和Gabriel Dos Reis于2003年向C++标准委员会提出了一种用于编译期求值的更好的机制。他们的目标：

- 让编译时计算达到**类型安全**
- 通过将计算移至编译时，提升运行效率
- 支持嵌入式编程
- 直接支持元编程（而非模板元编程）
- 让编译时编程和“普通编程”类似



2003年提议实现：允许在常量表达式中使用以`constexpr`为前缀的函数，还允许**常量表达式**使用简单的用户自定义类型，即**字面值常量**，这些**字面值常量**是一种所有运算都是`constexpr`的类型。



## C++标准

C++标准委员会从C++11开始支持Bjarne Stroustrup和Gabriel Dos Reis的提议：

- C++11引入`constexpr`关键字，此时`constexpr`可修饰变量亦可函数，但是要求函数必须是**纯函数**；
- C++14标准移除了C++11的大部分限制，允许constexpr函数使用局部变量，同时实现对其他函数的支持；
- C++17 将 constexpr 关键字引⼊到 if 语句，允许lambda声明为constexpr；
- C++20允许将字面值类型用做模板参数。

到C++20对`constexpr`的完整支持，`constexpr`标准化跨越了13年，由4个标准实现。C++20也是最接近最初语言设计模板的版本，但是`constexpr` 函数的设计其实也不够严谨，所以 C++20 又引入了 `consteval`；由于`constexpr`仅能实现**编译时常量求值**，为了解决**编译时非常量求值**问题，C++20又引入了`constinit`关键字。


**具备下述条件的函数，我们称之为纯函数**

- 函数无法访问非本地对象
- 函数不能对调用者的环境产生副作用



## C++11

C++11中的`constexpr`可修饰变量亦可修饰函数。但是无论是修饰变量还是函数，都要求其必须能在**编译期常量求值**。





## C++20