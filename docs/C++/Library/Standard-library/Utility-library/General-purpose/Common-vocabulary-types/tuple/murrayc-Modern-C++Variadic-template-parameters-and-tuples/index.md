# murrayc [Modern C++: Variadic template parameters and tuples](https://www.murrayc.com/permalink/2015/12/05/modern-c-variadic-template-parameters-and-tuples/)

### Variadic Templates

C++11 lets us define [variadic templates](https://en.wikipedia.org/wiki/Variadic_template), taking any amount of parameters, of any type, instead of just a specific number of parameters. Then, when we use the template, we can not only specify the types, we can specify an arbitrary amount of different types. For instance,

```c++
template <class... T_values>
class Base {
public
  virtual void something(T_values... values) = 0;
};
 
class Derived1 : public Base<int, short, double> {
public:
  void something(int a, short b, double c) override;
};
 
class Derived2 : public Base<std::string, char> {
public:
  void something(std::string a, char b) override;
};
```

This is useful in extremely generic code such as libsigc++. We are gradually [using this in libsigc++](https://bugzilla.gnome.org/show_bug.cgi?id=753612) and [in glibmm](https://bugzilla.gnome.org/show_bug.cgi?id=755613), along with [template aliases](http://en.cppreference.com/w/cpp/language/type_alias), to replace code that was previously generated by perl and python scripts to produce multiple versions of each C++ template, with various numbers of parameters. In the meantime, I’ve been playing with variadic templates in a separate experimental project and this is what I’ve learned along the way.

> NOTE: 上诉展示了variadic template的一种用途: code generation。

### Parameter Packs

The “`class… T_values`” there is called a template [parameter pack](http://en.cppreference.com/w/cpp/language/parameter_pack). If you are just templating a function then it’s called a function parameter pack:

```c++
class Thing {
public:
  template <class... T_values>
  void something(T_values... values) = 0;
};
```

### Expanding a Parameter Pack

The “`T… values`” in that method signature is us expanding (or unpacking) the parameter pack in a [function parameter list](http://en.cppreference.com/w/cpp/language/parameter_pack#Function_parameter_list). You can use the `…` in various ways in the function parameter list. For instance, to receive the types as const references:

```c++
template <class... T_values>
class Thing {
public:
  void something(const T_values&... values) = 0;
};
```

In your template, you can then call another method with that parameter pack, by [expanding](http://en.cppreference.com/w/cpp/language/parameter_pack#Pack_expansion) (or unpacking) it into the [function argument list](http://en.cppreference.com/w/cpp/language/parameter_pack#Function_argument_lists). For instance, with “values…”:

```c++
template <class... T_values>
class Thing {
public:
  void something(T_values... values) {
    something_else(values...);
  };
```

You can write more complex patterns to change how the parameter pack is expanded. For instance:

```c++
template <class... T_values>
class Thing {
public:
  void something(T_values... values) {
    something_else((values + 1)...);
  };
 
  void other_thing(T_values... values) {
    something_else(const_cast<T>(values)...);
  };
```

### Storing a Parameter Pack in a `std::tuple`

However, if you want to keep the parameter values around and use them at some later time, you’ll need to store them in a [std::tuple](http://en.cppreference.com/w/cpp/utility/tuple). I think this is why `std::tuple` exists. For instance:

```c++
template <class... T_values>
class Thing {
public:
  void something(T_values... values) {
    tuple = std::tuple<T_values...>(values...);
  }
 
private:
  std::tuple<T_values..> tuple_;
};
```

### Expanding a `std::tuple`

Then you have another problem. You probably want to call some method with those values. But now you have a tuple instead of a parameter pack. Trick with [std::index_sequence<>](http://en.cppreference.com/w/cpp/utility/integer_sequence#Helper_templates) and a helper method lets you call a normal method (that takes normal parameters), passing a tuple that holds those parameter values:

```c++
template <class... T_values>
class Thing {
public:
  void something(T_values... values) {
    tuple_ = std::tuple<T_values...>(values...);
  }
 
  void do_something_with_values() {
     call_yadda_with_tuple(tuple_,
      std::index_sequence_for<T_value...>())
  }
 
  void yadda(T... values);
 
private:
  //The helper method.
  template<std::size_t... Is>
  void call_yadda_with_tuple(const std::tuple<T_values...>& tuple,
    std::index_sequence<Is...>) {
    yadda(std::get<Is>(tuple)...);
  }
 
  std::tuple<T_values...> tuple_;
};
```

Unfortunately, this does clutter up your code. I haven’t yet managed to write a simple generic call_function_with_tuple(f, tuple) helper method. I hope it is possible.

Parameter packs are part of the C++ language. std::tuple<> and std::index_sequence<> are part of the C++ standard library, apparently added specifically for use with parameter packs. I can see the sense in keeping the language as simple as possible, as long as you can provide what you need via library code in that language. But the end result is not very attractive in this case. Luckily, hopefully, this isn’t something you’ll need to use much anyway.

At this point, any reader who already doesn’t like C++’s complexity will like it even less. Showing them a related thousand-line g++ compilation error should turn them away for good (clang++’s compilation errors are much clearer). But if you really like compile-time type-safety, and if you really like to avoid copy/pasted code, you might like that this is at all possible.

It would be understandable for coding guidelines to discourage the use of variadic templates except in special cases, until people are more familiar with them.

### Manipulating Tuples

Of course, you might need to call methods with just some of the parameters from the parameter pack, or some combination of parameter packs. Once you have the parameters in a std::tuple, you can manipulate that tuple with some more template cleverness. For instance:

- [std::tuple_cat()](http://en.cppreference.com/w/cpp/utility/tuple/tuple_cat) concatenates two tuples into one.
- But I recently needed a [tuple_cdr() ](https://github.com/murraycu/murrayc-dp-algorithms/blob/master/murraycdp/utils/tuple_cdr.h#L57)to remove the first item from the tuple, leaving me the rest.
- A tuple_car() would just do std::get(tuple) to get the first time, so nobody bothers to write one.
- I even needed a [tuple_interlace()](https://github.com/murraycu/murrayc-dp-algorithms/blob/master/murraycdp/utils/tuple_interlace.h#L91) to interlace two tuples together, turning a, b and c, d into a, c, b, d.

It all starts to feel very [lisp](https://en.wikipedia.org/wiki/Lisp_%28programming_language%29#Lists)y. Luckily there are [lots of people on StackOverflow](http://stackoverflow.com/search?q=std%3A%3Atuple) who enjoy discussing how to implement these. I feel there should be more functions like std::tuple_cat() in the standard C++ library, or maybe in some open source library.

Once you have your new tuple, you’ll probably need to use std::make_index_sequence<> instead of std::index_sequence_for<>, to call your call_*_with_tuple() helper method, like so:

```c++
void do_something_more() {
  const auto combined_tuple = std::tuple_cat(tuple1_, tuple2_);
  constexpr auto tuple_size =
      std::tuple_size<decltype(combined_tuple)>::value;
  call_yadda_with_tuple(tuple,
    std::make_index_sequence<tuple_size>());}
```

