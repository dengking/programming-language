<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- saved from url=(0108)https://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html -->
<html itemscope="" itemtype="http://schema.org/Blog"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<meta name="verify-v1" content="FCkahqY+3mcG8B/UT7dCQfwZnT1n5kVlTSTB1wLdNaY=">
<meta itemprop="name" content="Multithreading in C++0x part 6: Lazy initialization and double-checked locking with atomics">
<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.justsoftwaresolutions.co.uk/index.rss">
    <title>Multithreading in C++0x part 6: Lazy initialization and double-checked locking with atomics | Just Software Solutions - Custom Software Development</title>
<link href="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/format.css" rel="stylesheet" type="text/css">
<!--[if gte IE 5]><![if lt IE 7]>
<link href="/ie_format.css" rel="stylesheet" type="text/css">
<![endif]>
<![if gte IE 7]>
<link href="/ie7_format.css" rel="stylesheet" type="text/css">
<![endif]><![endif]-->

  <script async="" src="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/async-ads.js.download"></script><script src="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/cse_element__en.js.download" type="text/javascript"></script><link type="text/css" rel="stylesheet" href="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/default+en.css"><link type="text/css" rel="stylesheet" href="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/default.css"><style type="text/css">.gsc-control-cse{font-family:arial, sans-serif}.gsc-control-cse .gsc-table-result{font-family:arial, sans-serif}.gsc-refinementsGradient{background:linear-gradient(to left,rgba(255,255,255,1),rgba(255,255,255,0))}.gsc-control-cse{border-color:#FFFFFF;background-color:#FFFFFF}input.gsc-input,.gsc-input-box,.gsc-input-box-hover,.gsc-input-box-focus{border-color:#D9D9D9}.gsc-search-button-v2,.gsc-search-button-v2:hover,.gsc-search-button-v2:focus{border-color:#666666;background-color:#CECECE;background-image:none;filter:none}.gsc-search-button-v2 svg{fill:#FFFFFF}.gsc-tabHeader.gsc-tabhActive,.gsc-refinementHeader.gsc-refinementhActive{color:#CCCCCC;border-color:#CCCCCC;background-color:#FFFFFF}.gsc-tabHeader.gsc-tabhInactive,.gsc-refinementHeader.gsc-refinementhInactive{color:#CCCCCC;border-color:#CCCCCC;background-color:#FFFFFF}.gsc-webResult.gsc-result,.gsc-results .gsc-imageResult{border-color:#FFFFFF;background-color:#FFFFFF}.gsc-webResult.gsc-result:hover{border-color:#FFFFFF;background-color:#FFFFFF}.gs-webResult.gs-result a.gs-title:link,.gs-webResult.gs-result a.gs-title:link b,.gs-imageResult a.gs-title:link,.gs-imageResult a.gs-title:link b{color:#0000CC}.gs-webResult.gs-result a.gs-title:visited,.gs-webResult.gs-result a.gs-title:visited b,.gs-imageResult a.gs-title:visited,.gs-imageResult a.gs-title:visited b{color:#0000CC}.gs-webResult.gs-result a.gs-title:hover,.gs-webResult.gs-result a.gs-title:hover b,.gs-imageResult a.gs-title:hover,.gs-imageResult a.gs-title:hover b{color:#0000CC}.gs-webResult.gs-result a.gs-title:active,.gs-webResult.gs-result a.gs-title:active b,.gs-imageResult a.gs-title:active,.gs-imageResult a.gs-title:active b{color:#0000CC}.gsc-cursor-page{color:#0000CC}a.gsc-trailing-more-results:link{color:#0000CC}.gs-webResult .gs-snippet,.gs-fileFormatType{color:#000000}.gs-webResult div.gs-visibleUrl{color:#008000}.gs-webResult div.gs-visibleUrl-short{color:#008000}.gs-webResult div.gs-visibleUrl-short{display:none}.gs-webResult div.gs-visibleUrl-long{display:block}.gs-promotion div.gs-visibleUrl-short{display:none}.gs-promotion div.gs-visibleUrl-long{display:block}.gsc-cursor-box{border-color:#FFFFFF}.gsc-results .gsc-cursor-box .gsc-cursor-page{border-color:#CCCCCC;background-color:#FFFFFF;color:#CCCCCC}.gsc-results .gsc-cursor-box .gsc-cursor-current-page{border-color:#CCCCCC;background-color:#FFFFFF;color:#CCCCCC}.gsc-webResult.gsc-result.gsc-promotion{border-color:#336699;background-color:#FFFFFF}.gsc-completion-title{color:#0000CC}.gsc-completion-snippet{color:#000000}.gs-promotion a.gs-title:link,.gs-promotion a.gs-title:link *,.gs-promotion .gs-snippet a:link{color:#0000CC}.gs-promotion a.gs-title:visited,.gs-promotion a.gs-title:visited *,.gs-promotion .gs-snippet a:visited{color:#0000CC}.gs-promotion a.gs-title:hover,.gs-promotion a.gs-title:hover *,.gs-promotion .gs-snippet a:hover{color:#0000CC}.gs-promotion a.gs-title:active,.gs-promotion a.gs-title:active *,.gs-promotion .gs-snippet a:active{color:#0000CC}.gs-promotion .gs-snippet,.gs-promotion .gs-title .gs-promotion-title-right,.gs-promotion .gs-title .gs-promotion-title-right *{color:#000000}.gs-promotion .gs-visibleUrl,.gs-promotion .gs-visibleUrl-short{color:#008000}.gcsc-find-more-on-google{color:#0000CC}.gcsc-find-more-on-google-magnifier{fill:#0000CC}</style><style type="text/css">.gscb_a{display:inline-block;font:27px/13px arial,sans-serif}.gsst_a .gscb_a{color:#a1b9ed;cursor:pointer}.gsst_a:hover .gscb_a,.gsst_a:focus .gscb_a{color:#36c}.gsst_a{display:inline-block}.gsst_a{cursor:pointer;padding:0 4px}.gsst_a:hover{text-decoration:none!important}.gsst_b{font-size:16px;padding:0 2px;position:relative;user-select:none;-webkit-user-select:none;white-space:nowrap}.gsst_e{vertical-align:middle;opacity:0.55;}.gsst_a:hover .gsst_e,.gsst_a:focus .gsst_e{opacity:0.72;}.gsst_a:active .gsst_e{opacity:1;}.gsst_f{background:white;text-align:left}.gsst_g{background-color:white;border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-webkit-box-shadow:0 2px 4px rgba(0,0,0,0.2);margin:-1px -3px;padding:0 6px}.gsst_h{background-color:white;height:1px;margin-bottom:-1px;position:relative;top:-1px}.gsib_a{width:100%;padding:4px 6px 0}.gsib_a,.gsib_b{vertical-align:top}.gssb_c{border:0;position:absolute;z-index:989}.gssb_e{border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-webkit-box-shadow:0 2px 4px rgba(0,0,0,0.2);cursor:default}.gssb_f{visibility:hidden;white-space:nowrap}.gssb_k{border:0;display:block;position:absolute;top:0;z-index:988}.gsdd_a{border:none!important}.gsq_a{padding:0}.gssb_a{padding:0 7px}.gssb_a,.gssb_a td{white-space:nowrap;overflow:hidden;line-height:22px}#gssb_b{font-size:11px;color:#36c;text-decoration:none}#gssb_b:hover{font-size:11px;color:#36c;text-decoration:underline}.gssb_g{text-align:center;padding:8px 0 7px;position:relative}.gssb_h{font-size:15px;height:28px;margin:0.2em;-webkit-appearance:button}.gssb_i{background:#eee}.gss_ifl{visibility:hidden;padding-left:5px}.gssb_i .gss_ifl{visibility:visible}a.gssb_j{font-size:13px;color:#36c;text-decoration:none;line-height:100%}a.gssb_j:hover{text-decoration:underline}.gssb_l{height:1px;background-color:#e5e5e5}.gssb_m{color:#000;background:#fff}.gssb_a{padding:0 9px}.gsib_a{padding:5px 9px 4px 9px}.gscb_a{line-height:27px}.gssb_e{border:0}.gssb_l{margin:5px 0}input.gsc-input::-webkit-input-placeholder{font-size:14px}input.gsc-input:-moz-placeholder{font-size:14px}input.gsc-input::-moz-placeholder{font-size:14px}input.gsc-input:-ms-input-placeholder{font-size:14px}input.gsc-input:focus::-webkit-input-placeholder{color:transparent}input.gsc-input:focus:-moz-placeholder{color:transparent}input.gsc-input:focus::-moz-placeholder{color:transparent}input.gsc-input:focus:-ms-input-placeholder{color:transparent}.gssb_c .gsc-completion-container{position:static}.gssb_c{z-index:5000}.gsc-completion-container table{background:transparent;font-size:inherit;font-family:inherit}.gssb_c > tbody > tr,.gssb_c > tbody > tr > td,.gssb_d,.gssb_d > tbody > tr,.gssb_d > tbody > tr > td,.gssb_e,.gssb_e > tbody > tr,.gssb_e > tbody > tr > td{padding:0;margin:0;border:0}.gssb_a table,.gssb_a table tr,.gssb_a table tr td{padding:0;margin:0;border:0}</style></head>
  <body>
<div id="bodycontainer">
<div class="top-box">
<div class="topcontent">
<h1 id="title">
<a href="https://www.justsoftwaresolutions.co.uk/">
<span id="titletext"></span>
<span id="just"><span class="firstletter">J</span>ust</span>
<span id="softwaresolutions">
<span id="software"><span class="firstletter">S</span>oftware</span>
<span id="solutions"><span class="firstletter">S</span>olutions</span>
</span>
</a>
</h1>
<div id="google-search">
<script type="text/javascript" async="" src="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/f.txt"></script><script>
  (function() {
    var cx = "003634933120822890516:kunc296lkq0";
    var gcse = document.createElement("script");
    gcse.type = "text/javascript";
    gcse.async = true;
    gcse.src = (document.location.protocol == "https:" ? "https:" : "http:") +
        "//www.google.com/cse/cse.js?cx=" + cx;
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<div id="___gcse_0"><div class="gsc-control-cse gsc-control-cse-en"><div class="gsc-control-wrapper-cse" dir="ltr"><form class="gsc-search-box gsc-search-box-tools" accept-charset="utf-8"><table cellspacing="0" cellpadding="0" class="gsc-search-box"><tbody><tr><td class="gsc-input"><div class="gsc-input-box" id="gsc-iw-id1"><table cellspacing="0" cellpadding="0" id="gs_id50" class="gstl_50 gsc-input" style="width: 100%; padding: 0px;"><tbody><tr><td id="gs_tti50" class="gsib_a"><input autocomplete="off" type="text" size="10" class="gsc-input" name="search" title="search" id="gsc-i-id1" dir="ltr" spellcheck="false" style="width: 100%; padding: 0px; border: none; margin: 0px; height: auto; background: url(&quot;https://www.google.com/cse/static/images/1x/en/branding.png&quot;) left center no-repeat rgb(255, 255, 255); outline: none;"></td><td class="gsib_b"><div class="gsst_b" id="gs_st50" dir="ltr"><a class="gsst_a" href="javascript:void(0)" title="Clear search box" role="button" style="display: none;"><span class="gscb_a" id="gs_cb50" aria-hidden="true">×</span></a></div></td></tr></tbody></table></div></td><td class="gsc-search-button"><button class="gsc-search-button gsc-search-button-v2"><svg width="13" height="13" viewBox="0 0 13 13"><title>search</title><path d="m4.8495 7.8226c0.82666 0 1.5262-0.29146 2.0985-0.87438 0.57232-0.58292 0.86378-1.2877 0.87438-2.1144 0.010599-0.82666-0.28086-1.5262-0.87438-2.0985-0.59352-0.57232-1.293-0.86378-2.0985-0.87438-0.8055-0.010599-1.5103 0.28086-2.1144 0.87438-0.60414 0.59352-0.8956 1.293-0.87438 2.0985 0.021197 0.8055 0.31266 1.5103 0.87438 2.1144 0.56172 0.60414 1.2665 0.8956 2.1144 0.87438zm4.4695 0.2115 3.681 3.6819-1.259 1.284-3.6817-3.7 0.0019784-0.69479-0.090043-0.098846c-0.87973 0.76087-1.92 1.1413-3.1207 1.1413-1.3553 0-2.5025-0.46363-3.4417-1.3909s-1.4088-2.0686-1.4088-3.4239c0-1.3553 0.4696-2.4966 1.4088-3.4239 0.9392-0.92727 2.0864-1.3969 3.4417-1.4088 1.3553-0.011889 2.4906 0.45771 3.406 1.4088 0.9154 0.95107 1.379 2.0924 1.3909 3.4239 0 1.2126-0.38043 2.2588-1.1413 3.1385l0.098834 0.090049z"></path></svg></button></td><td class="gsc-clear-button"><div class="gsc-clear-button" title="clear results">&nbsp;</div></td></tr></tbody></table></form><div class="gsc-results-wrapper-overlay"><div class="gsc-results-close-btn" tabindex="0"></div><div class="gsc-positioningWrapper"><div class="gsc-tabsAreaInvisible"><div aria-label="refinement" role="tab" class="gsc-tabHeader gsc-inline-block gsc-tabhActive">Custom Search</div><span class="gs-spacer"> </span></div></div><div class="gsc-positioningWrapper"><div class="gsc-tabsAreaInvisible"></div></div><div class="gsc-above-wrapper-area-invisible"><table cellspacing="0" cellpadding="0" class="gsc-above-wrapper-area-container"><tbody><tr><td class="gsc-result-info-container"><div class="gsc-result-info-invisible"></div></td><td class="gsc-orderby-container"><div class="gsc-orderby-invisible"><div class="gsc-orderby-label gsc-inline-block">Sort by:</div><div class="gsc-option-menu-container gsc-inline-block"><div class="gsc-selected-option-container gsc-inline-block"><div class="gsc-selected-option">Relevance</div><div class="gsc-option-selector"></div></div><div class="gsc-option-menu-invisible"><div class="gsc-option-menu-item gsc-option-menu-item-highlighted"><div class="gsc-option">Relevance</div></div><div class="gsc-option-menu-item"><div class="gsc-option">Date</div></div></div></div></div></td></tr></tbody></table></div><div class="gsc-adBlockInvisible"></div><div class="gsc-wrapper"><div class="gsc-adBlockInvisible"></div><div class="gsc-resultsbox-invisible"><div class="gsc-resultsRoot gsc-tabData gsc-tabdActive"><div><div class="gsc-expansionArea"></div></div></div></div></div></div><div class="gsc-modal-background-image" tabindex="0"></div></div></div></div></div>
</div>
<div id="topmenu">
<ul>
<li><a href="https://www.justsoftwaresolutions.co.uk/training.html">Training</a></li>
<li><a href="https://www.justsoftwaresolutions.co.uk/consultancy.html">Consultancy</a></li>
<li><a href="http://www.stdthread.co.uk/">Just::Thread Pro</a></li>
<li><a href="https://www.justsoftwaresolutions.co.uk/news/">News</a></li>
<li><a href="https://www.justsoftwaresolutions.co.uk/blog/">Blog</a></li>
<li><a href="https://www.justsoftwaresolutions.co.uk/contact.html">Contact Us</a></li>
</ul>
<div class="clear"></div>
</div>
</div>
<div id="bodybox">
<div id="main">
<div id="mainbackground">
<div id="menubox">
<div id="menubackground">
<div id="menucontent">
<div id="menu">
<div id="about" class="menu-section">
          <h3>About Us</h3>
<div id="about-inner">
<div id="sandspiral"></div>
          <ul>
            <li><a href="https://www.justsoftwaresolutions.co.uk/">Our Services</a></li>
            <li><a href="https://www.justsoftwaresolutions.co.uk/consultancy.html">Consultancy</a></li>
            <li><a href="https://www.justsoftwaresolutions.co.uk/training.html">Workshops and Training</a></li>
            <li><a href="https://www.justsoftwaresolutions.co.uk/custom_software_development.html">Custom Software Development</a></li>
            <li><a href="https://www.justsoftwaresolutions.co.uk/ethos.html">Our Ethos</a></li>
            <li><a href="https://www.justsoftwaresolutions.co.uk/contact.html">Contact us</a></li>
</ul>
</div>
</div>
<div id="technical-writings" class="menu-section">
          <h3>Technical Writings</h3>
          <ul>
            <li><a href="http://cplusplusconcurrencyinaction.com/">C++ Concurrency Book</a></li>
            <li><a href="https://www.justsoftwaresolutions.co.uk/publications.html">Articles and Publications</a></li>
            <li><a href="https://www.justsoftwaresolutions.co.uk/conferences.html">Conference Presentations</a></li>
            <li><a href="https://www.justsoftwaresolutions.co.uk/blog/">Recent Blog Entries</a></li>
            <li><a href="https://www.justsoftwaresolutions.co.uk/threading/">Multithreading Blog Entries</a></li>
            <li><a href="https://www.justsoftwaresolutions.co.uk/cplusplus/">C++ Blog Entries</a></li>
            </ul>
          <h3><a name="subscribe"></a>Subscribe to Blog</h3>
          <ul>
            <li><a href="https://www.justsoftwaresolutions.co.uk/index.rss">Subscribe by RSS <img class="rss" src="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/feed-icon-14x14.png" alt="RSS feed"></a></li>
          </ul>    

<!-- AWeber Web Form Generator 3.0 -->
<form method="post" class="af-form-wrapper" action="https://www.aweber.com/scripts/addlead.pl">
<div style="display: none;">
<input type="hidden" name="meta_web_form_id" value="1011135726">
<input type="hidden" name="meta_split_id" value="">
<input type="hidden" name="listname" value="jssblog">
<input type="hidden" name="redirect" value="https://www.aweber.com/thankyou-coi.htm?m=text" id="redirect_b02a2c2d57481294a119c00efe906b59">

<input type="hidden" name="meta_adtracking" value="Blog_signup_form">
<input type="hidden" name="meta_message" value="1">
<input type="hidden" name="meta_required" value="name,email">
<input type="hidden" name="meta_forward_vars" value="">
<input type="hidden" name="meta_tooltip" value="">
</div>
<p>Enter your details below to receive updates by email</p>
<div id="af-body-1011135726" class="af-body af-standards">
<div class="af-element">
<label class="previewLabel" for="awf_field-1607387">Name: </label>
<div class="af-textWrap">
<input id="awf_field-1607387" type="text" name="name" class="text" value="">
</div>
<div class="af-clear"></div></div>
<div class="af-element">
<label class="previewLabel" for="awf_field-1607388">Email: </label>
<div class="af-textWrap"><input class="text" id="awf_field-1607388" type="text" name="email" value="">
</div><div class="af-clear"></div>
</div>
<div class="af-element buttonContainer">
<input name="submit" class="submit" type="submit" value="Subscribe me">
<div class="af-clear"></div>
</div>
<div class="af-element privacyPolicy" style="text-align: center"><p><a href="https://www.aweber.com/permission.htm" target="_blank">We respect your email privacy</a></p>
<div class="af-clear"></div>
</div>
</div>
<img src="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/displays.htm" border="0">
</form>
<script type="text/javascript">
    (function() {
        var IE = /*@cc_on!@*/false;
        if (!IE) { return; }
        if (document.compatMode && document.compatMode == "BackCompat") {
            if (document.getElementById("af-form-1011135726")) {
                document.getElementById("af-form-1011135726").className = "af-form af-quirksMode";
            }
            if (document.getElementById("af-body-1011135726")) {
                document.getElementById("af-body-1011135726").className = "af-body inline af-quirksMode";
            }
            if (document.getElementById("af-header-1011135726")) {
                document.getElementById("af-header-1011135726").className = "af-header af-quirksMode";
            }
            if (document.getElementById("af-footer-1011135726")) {
                document.getElementById("af-footer-1011135726").className = "af-footer af-quirksMode";
            }
        }
    })();
</script>

<!-- /AWeber Web Form Generator 3.0 -->
</div><h3>Blog Archives</h3><ul class="flatarchives"><li><a href="https://www.justsoftwaresolutions.co.uk/2020/08/">August 2020 (1)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2020/03/">March 2020 (1)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2019/">2019 (10)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2017/">2017 (13)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2016/">2016 (11)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2015/">2015 (18)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2014/">2014 (7)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2013/">2013 (4)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2012/">2012 (6)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2011/">2011 (11)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2010/">2010 (24)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2009/">2009 (25)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2008/">2008 (41)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2007/">2007 (26)</a></li><li><a href="https://www.justsoftwaresolutions.co.uk/2006/">2006 (13)</a></li></ul></div>
</div>
</div>
</div>
<div id="maincontent"><h1 class="entry-title"><a href="https://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html">Multithreading in C++0x part 6: Lazy initialization and double-checked locking with atomics</a></h1><h3 class="dateheader">Thursday, 13 August 2009</h3>
<p><em>This is the sixth in a series of blog posts introducing the new
C++0x thread library. So far we've looked at the various ways of <a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-C++0x-part-1-starting-threads.html">starting
threads in C++0x</a> and <a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-C++0x-part-4-protecting-shared-data.html">protecting
shared data with mutexes</a>. See the end of this article for a full
set of links to the rest of the series.</em></p>

<p>I had intended to write about the use of the new <code><a href="http://www.stdthread.co.uk/doc/headers/mutex/lock.html">std::lock()</a></code>
for avoiding deadlock in this article. However, there was a post on
comp.std.c++ this morning about lazy initialization, and I thought I'd
write about that instead. <code><a href="http://www.stdthread.co.uk/doc/headers/mutex/lock.html">std::lock()</a></code>
can wait until next time.</p>

<h3>Lazy Initialization</h3>

<p>The classic lazy-initialization case is where you have an object
that is expensive to construct but isn't always needed. In this case
you can choose to only initialize it on first use:

</p><pre class="listing">class lazy_init
{
    mutable std::unique_ptr&lt;expensive_data&gt; data;
public:
    expensive_data const&amp; get_data() const
    {
        if(!data)
        {
            data.reset(new expensive_data);
        }
        return *data;
    }
};
</pre>

<p>However, we can't use this idiom in multi-threaded code, since
there would be a data race on the accesses to <code>data</code>. Enter <code><a href="http://www.stdthread.co.uk/doc/headers/mutex/call_once.html">std::call_once()</a></code>
— by using an instance of <code><a href="http://www.stdthread.co.uk/doc/headers/mutex/once_flag.html">std::once_flag</a></code>
to protect the initialization we can make the data race go away:

</p><pre class="listing">class lazy_init
{
    mutable std::once_flag flag;
    mutable std::unique_ptr&lt;expensive_data&gt; data;

    void do_init() const
    {
        data.reset(new expensive_data);
    }
public:
    expensive_data const&amp; get_data() const
    {
        std::call_once(flag,&amp;lazy_init::do_init,this);
        return *data;
    }
};
</pre>

<p>Concurrent calls to <code>get_data()</code> are now safe: if the
data has already been initialized they can just proceed
concurrently. If not, then all threads calling concurrently except one
will wait until the remaining thread has completed the
initialization.</p>

<h3>Reinitialization</h3>

<p>This is all very well if you only want to initialize the
  data <em>once</em>. However, what if you need to update the data
  — perhaps it's a <em>cache</em> of some rarely-changing data
  that's expensive to come
  by. <code><a href="http://www.stdthread.co.uk/doc/headers/mutex/call_once.html">std::call_once()</a></code>
  doesn't support multiple calls (hence the name). You could of course
  protect the data with a mutex, as shown below:</p>

<pre class="listing">class lazy_init_with_cache
{
    mutable std::mutex m;
    mutable std::shared_ptr&lt;const expensive_data&gt; data;

public:
    std::shared_ptr&lt;const expensive_data&gt; get_data() const
    {
        std::lock_guard&lt;std::mutex&gt; lk(m);
        if(!data)
        {
            data.reset(new expensive_data);
        }
        return data;
    }
    void invalidate_cache()
    {
        std::lock_guard&lt;std::mutex&gt; lk(m);
        data.reset();
    }
};
</pre>

<p>Note that in this case we return a <code>std::shared_ptr&lt;const
expensive_data&gt;</code> rather than a reference to avoid a race
condition on the data itself — this ensures that the copy held
by the calling code will be valid (if out of date) even if another
thread calls <code>invalidate_cache()</code> before the data can be
used.</p>

<p>This "works" in the sense that it avoids data races, but if the
updates are rare and the reads are frequent then this may cause
unnecessary serialization when multiple threads
call <code>get_data()</code> concurrently. What other options do we
have?</p>

<h3>Double-checked locking returns</h3>

<p>Much has been written about
how <a href="http://en.wikipedia.org/wiki/Double-checked_locking">double-checked
locking</a> is broken when using multiple threads. However, the chief
cause of the problem is that the sample code uses plain non-atomic
operations to check the flag outside the mutex, so is subject to a
data race. You can overcome this by careful use of the C++0x atomics,
as shown in the example below:</p>

<pre class="listing">class lazy_init_with_cache
{
    mutable std::mutex m;
    mutable std::shared_ptr&lt;const expensive_data&gt; data;

public:
    std::shared_ptr&lt;const expensive_data&gt; get_data() const
    {
        std::shared_ptr&lt;const expensive_data&gt; result=
            std::atomic_load_explicit(&amp;data,std::memory_order_acquire);
        if(!result)
        {
            std::lock_guard&lt;std::mutex&gt; lk(m);
            result=data;
            if(!result)
            {
                result.reset(new expensive_data);
                std::atomic_store_explicit(&amp;data,result,std::memory_order_release);
            }
        }
        return result;
    }
    void invalidate_cache()
    {
        std::lock_guard&lt;std::mutex&gt; lk(m);
        std::shared_ptr&lt;const expensive_data&gt; dummy;
        std::atomic_store_explicit(&amp;data,dummy,std::memory_order_relaxed);
    }
};
</pre>

<p>Note that in this case, <em>all writes to <code>data</code> use
atomic operations, even those within the mutex lock</em>. This is
necessary in order to ensure that the atomic load operation at the
start of <code>get_data()</code> actually has a coherent value to read
— there's no point doing an atomic load if the stores are not
atomic, otherwise you might atomically load some half-written
data. Also, the atomic load and store operations ensure that the
reference count on the <code>std::shared_ptr</code> object is
correctly updated, so that the <code>expensive_data</code> object is
correctly destroyed when the last <code>std::shared_ptr</code> object
referencing it is destroyed.</p>

<p>If our atomic load actually returned a non-<code>NULL</code> value
then we can use that, just as we did before. However, if it
returned <code>NULL</code> then we need to lock the mutex and try
again. This time we can use a plain read of <code>data</code>, since
the mutex is locked. If we still get <code>NULL</code> then we need to
do the initialization. However, we can't just
call <code>data.reset()</code> like before, since that is not
atomic. Instead we must create a local <code>std::shared_ptr</code>
instance with the value we want, and store the value with an atomic
store operation. We can use <code>result</code> for the local value,
since we want the value in that variable anyway.</p>

<p>In <code>invalidate_cache()</code> we must also store the value
using <code>std::atomic_store_explicit()</code>, in order to ensure
that the <code>NULL</code> value is correctly read
in <code>get_data()</code>. Note also that we must also lock the mutex
here, in order to avoid a data race with the initialization code
inside the mutex lock in <code>get_data()</code>.</p>

<h3>Memory ordering</h3>

<p>By using <code>std::atomic_load_explicit()</code>
and <code>std::atomic_store_explicit()</code> we can specify the
  <a href="http://www.stdthread.co.uk/doc/headers/cstdatomic/memory_order.html">memory
  ordering</a> requirements of the operations. We could have just
  used <code>std::atomic_load()</code>
  and <code>std::atomic_store()</code>, but those would have
  implied <code>std::memory_order_seq_cst</code>, which is overkill in
  this scenario. What we need is to ensure that if a
  non-<code>NULL</code> value is read in <code>get_data()</code> then
  the actual creation of the associated object <em>happens-before</em>
  the read. The store in <code>get_data()</code> must therefore
  use <code>std::memory_order_release</code>, whilst the load
  uses <code>std::memory_order_acquire</code>.</p>

<p>On the other hand, the store in <code>invalidate_cache()</code> can
  merrily use <code>std::memory_order_relaxed</code>, since there is
  no data associated with the store: if the load
  in <code>get_data()</code> reads <code>NULL</code> then the mutex
  will be locked, which will handle any necessary synchronization.</p>

<p>Whenever you use atomic operations, you have to make sure that the
  memory ordering is correct, and that there are no races. Even in
  such a simple case such as this it is not trivial, and I would not
  recommend it unless profiling has shown that this is really a
  problem.</p>

<p><strong>Update: As if to highlight my previous point about the
trickiness of atomic operations, Dmitriy correctly points out in the
comments that the use of <code>std::shared_ptr</code> to access
the <code>expensive_data</code> implies a reference count, which is a
real performance suck in multithreaded code. Whatever the memory
ordering constraints we put on it, every thread doing the reading has
to update the reference count. This is thus a source of contention,
and can seriously limit scalability even if it doesn't force full
serialization. The same issues apply to multiple-reader single-writer
mutexes — Joe Duffy has written about them
<a href="http://www.bluebytesoftware.com/blog/2009/02/21/AMoreScalableReaderwriterLockAndABitLessHarshConsiderationOfTheIdea.aspx">over
on his blog</a>. Time it on your platform with just a mutex (i.e. no
double-checked locking), and with the atomic operations, and use
whichever is faster. Alternatively, use a memory reclamation scheme
specially tailored for your usage.</strong></p>

<h3>Next time</h3>

<p>In the next part of this series I'll cover the use
of <code><a href="http://www.stdthread.co.uk/doc/headers/mutex/lock.html">std::lock()</a></code>
that I was intending to cover in this installment.</p>

<p><a href="http://www.justsoftwaresolutions.co.uk/index.rss">Subscribe
to the RSS feed <img class="rss" src="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/feed-icon-14x14.png" alt="RSS feed"></a>
or <a href="http://www.justsoftwaresolutions.co.uk/#subscribe">email
newsletter</a> for this blog to be sure you don't miss the rest of the
series.</p>

<h3>Try it out</h3>

<p>If you're using Microsoft Visual Studio 2008 or g++ 4.3 or 4.4 on
Ubuntu Linux you can try out the examples from this series using our
<code><a href="http://www.stdthread.co.uk/">just::thread</a></code>
implementation of the new C++0x thread library. <strong><a href="http://www.stdthread.co.uk/order.html">Get your copy
today</a></strong>.</p>

<p>Note: since <code>std::shared_ptr</code> is part of the library
  supplied with the
  compiler, <code><a href="http://www.stdthread.co.uk/">just::thread</a></code>
  cannot provide the atomic functions for <code>std::shared_ptr</code>
  used in this article.</p>


<h3><a name="series">Multithreading in C++0x Series</a></h3>

<p>Here are the posts in this series so far:</p>

<ul>

<li><a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-1-starting-threads.html">Multithreading
in C++0x Part 1: Starting Threads</a></li>

<li><a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-2-function-objects-and-arguments.html">Multithreading
in C++0x Part 2: Starting Threads with Function Objects and
Arguments</a></li>

<li><a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-3.html">Multithreading
in C++0x Part 3: Starting Threads with Member Functions and Reference
Arguments</a></li>

<li><a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-4-protecting-shared-data.html">Multithreading
in C++0x Part 4: Protecting Shared Data</a></li>

<li><a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-5-flexible-locking.html">Multithreading
in C++0x Part 5: Flexible locking
with <code>std::unique_lock&lt;&gt;</code></a></li>

<li><a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html">Multithreading
in C++0x part 6: Lazy initialization and double-checked locking with
atomics</a></li>

<li><a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-7-locking-multiple-mutexes.html">Multithreading
in C++0x part 7: Locking multiple mutexes without deadlock</a></li>

<li><a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-8-futures-and-promises.html">Multithreading
in C++0x part 8: Futures, Promises and Asynchronous Function Calls</a></li>

</ul>
<p align="right">Posted by Anthony Williams<br><i>[/  <a href="https://www.justsoftwaresolutions.co.uk/threading/">threading</a> /] <a href="https://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html">permanent link</a></i><br> <small> Tags:  <a href="http://technorati.com/tag/concurrency" rel="tag">concurrency</a>,  <a href="http://technorati.com/tag/multithreading" rel="tag">multithreading</a>,  <a href="http://technorati.com/tag/C++0x" rel="tag">C++0x</a>,  <a href="http://technorati.com/tag/thread" rel="tag">thread</a>,  <a href="http://technorati.com/tag/atomics" rel="tag">atomics</a> <br>  <a href="http://www.stumbleupon.com/submit?url=https%3A%2F%2Fwww.justsoftwaresolutions.co.uk%2Fthreading%2Fmultithreading-in-c%2B%2B0x-part-6-double-checked-locking.html&amp;title=Multithreading%20in%20C%2B%2B0x%20part%206%3A%20Lazy%20initialization%20and%20double-checked%20locking%20with%20atomics"> Stumble It! <img src="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/stumbleupon.png" width="16" height="16" class="sm" alt="stumbleupon logo"></a> | <a href="http://reddit.com/submit?url=https%3A%2F%2Fwww.justsoftwaresolutions.co.uk%2Fthreading%2Fmultithreading-in-c%2B%2B0x-part-6-double-checked-locking.html&amp;title=Multithreading%20in%20C%2B%2B0x%20part%206%3A%20Lazy%20initialization%20and%20double-checked%20locking%20with%20atomics">Submit to Reddit <img src="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/reddit.png" width="16" height="16" class="sm" alt="reddit logo"></a> | <a href="http://www.dzone.com/links/add.html?url=https%3A%2F%2Fwww.justsoftwaresolutions.co.uk%2Fthreading%2Fmultithreading-in-c%2B%2B0x-part-6-double-checked-locking.html&amp;title=Multithreading%20in%20C%2B%2B0x%20part%206%3A%20Lazy%20initialization%20and%20double-checked%20locking%20with%20atomics">Submit to DZone <img src="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/dzone.png" width="16" height="16" class="sm" alt="dzone logo"></a></small></p><p><a href="https://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html#makecomment">Comment on this post</a></p><p>If you liked this post, why not <a href="https://www.justsoftwaresolutions.co.uk/index.rss">subscribe to the RSS feed <img class="rss" src="./Multithreading in C++0x part 6_ Lazy initialization and double-checked locking with atomics _ Just Software Solutions - Custom Software Development_files/feed-icon-14x14.png" alt="RSS feed"></a> or <a href="http://twitter.com/a_williams">Follow me on Twitter</a>? You can also subscribe to this blog by email using the <a href="https://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html#subscribe">form on the left</a>.</p><div class="comments"><h3>12 Comments</h3>
<div class="comment"><div class="comment-content">How 
std::shared_ptr&lt;const expensive_data&amp;rt; result=
            std::atomic_load_explicit(&amp;data,std::memory_order_acquire);
will avoid unnecessary serialization when reads are frequent?
I do not see any technique for that that is at least as efficient as mutex and does not covered by patents and applicable in general purpose prepacked class...
</div><div class="comment-author">by Dmitriy V'jukov at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content">The variant that uses std::call_once and returns 'expensive_data const&amp;' must be quite efficient.
However I would not recommend to use std::shared_ptr&lt;&gt; as a return value in such scenario. It along with strong atomic load of global shared_ptr will kill performance to death provided frequent reads. It does not worth invalidation capability.
Atomic reference counting is a performance anti-pattern in the multicore world.
It's perfectly legal example of threading API usage, though. Just not what must be recommended in tutorials, people inclined to get tutorial examples too seriously.
What do you think, Anthony?
</div><div class="comment-author">by Dmitriy V'jukov at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content"><p>Hi Dmitriy,</p>
<p>You are right to be concerned about the implementation of std::atomic_load_explicit for shared_ptr. The simplest implementation would use an internal spin lock, which is potentially marginally more efficient than a full-blown mutex, but will still enforce serialization.</p>
<p>Just because algorithms are patented doesn't mean implementations can't use them --- it just means they need to get permission from the patentee (presumably for a fee).</p>
<p>Regarding your second point about reference counting, you're probably right. I was trying to avoid having to deal with the issues around safely accessing the returned object, and atomic shared_ptr access was the simplest way I could think of this morning. It is likely to be considerably less efficient than the call_once scenario, but the circumstances are different.</p></div><div class="comment-author">by Anthony Williams at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content"><p>I think the member function do_init in the 2nd example should be const.</p>
<p>Interesting artices!</p>
<p>SG</p></div><div class="comment-author">by SG at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content"><p>Thank you for writing this informative article.  One wrinkle I think you are forgetting is that there are varying levels of thread safety. One definition of the lowest level of thread safety is when the following conditions are true:</p>
<p>   1) It is safe for several threads to have simultaneous read-only access to the same object.
   2) It is safe for several threads to have simultaneous read-write access to different objects.</p>
<p>If you only want to provide basic thread safety then you don't need to protect the invalidate_cache() method.  This is a non-const method of the lazy_init_with_cache class, so if a client calls it on an object that is shared by several threads it is the client's responsibility to protect the code, probably with his own mutex or lock.  On the other hand, the get_data() method is const, so a client can reasonably expect that it is safe to call this from several threads without locks.  Thus it is your responsibility to make get_data() safe to call simultaneously from several threads, but not invalidate_data().</p></div><div class="comment-author">by Joe at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content"><p>Well spotted SG. Thanks. I've updated the code.</p></div><div class="comment-author">by Anthony Williams at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content"><p>Hi Joe,</p>
<p>I agree that when we talk about something being "thread-safe" it is important to think about what operations are being done - going for the general case will just lead to unnecessary overhead.</p>
<p>The reason I put the lock in invalidate_cache() is that it prevents a race between invalidate_cache() and get_data(). There's no point locking the mutex in get_data() if another thread can just call invalidate_cache() and stamp all over our data without acquiring the mutex.</p>
<p>If in your particular case the program logic guarantees that no threads can call get_data() whilst any thread is calling invalidate_cache() then you don't need the internal locks.</p></div><div class="comment-author">by Anthony Williams at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content"><p>Hi Anthony,</p>
<p>At least POSIX guarantees that mutex lock and unlock provide memory barrier (as does thread creation). More specifically, unlock provides (all) memory release semantics while lock provides (all) memory acquire semantics. This way different threads using mutex lock and unlock consistently achieve coherent view of data protected by the mutex. Notice that mutex lock and unlock APIs do not provide a way to specify which memory gets affected, so they must operate in a way that affects any memory.</p>
<p>In this light, it is not necessary to use atomic operations while the mutex is locked, because mutex unlock does memory release anyway.</p>
<p>Another thing I'd like to mention is that in the first version of:</p>
<p>    std::shared_ptr&lt;const expensive_data&gt; get_data() const
    {
        std::lock_guard&lt;std::mutex&gt; lk(m);
        if(!data)
        {
            data.reset(new expensive_data);
        }
        return data; // &lt;---- copying here, the mutex is still held
    } // &lt;---- release the mutex here</p>
<p>Is copying data to the return value while still holding the mutex, which is suboptimal, since the mutex only protects the initialisation of data. A more optimal version should no hold the mutex after data has been initialised:</p>
<p>    std::shared_ptr&lt;const expensive_data&gt; get_data() const
    {
        {
            std::lock_guard&lt;std::mutex&gt; lk(m);
            if(!data)
                data.reset(new expensive_data);
        } // &lt;---- release the mutex here
        return data; // &lt;---- copying data, mutex is not held
    }</p>
<p>Max</p></div><div class="comment-author">by Maxim Yegorushkin at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content"><p>Hi Max,</p>
<p>Firstly, you're right about the mutex-only version: once data is initialized then you can release the mutex before returning the value.</p>
<p>However, you are wrong about the double-checked locking example. Yes, mutex unlock provides full release semantics, so we do not normally need to use atomics with a mutex. However, we are reading the value *outside* the mutex lock, and only acquiring the lock if this read returns NULL. Other threads can perform this read *even whilst one thread has the mutex locked*. Consequently, we need release semantics on the *store itself*. The fact that the unlock that is executed moments later has release semantics is not enough --- moments later might be too late if a concurrently-executing thread has already read the freshly-stored non-NULL value and tried to use it.</p></div><div class="comment-author">by Anthony Williams at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content"><p>Hi Anthony,</p>
<p>I see what you mean. If the store does not have release semantics there is a possibility that another thread starts using the object after the store but before the release, so that some of the effects of constructing a new object may not have become visible to the other thread. Is that right?</p>
<p>Max</p>
</div><div class="comment-author">by Maxim Yegorushkin at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content"><p>Hi Max,</p>
<p>Yes, that's right.</p></div><div class="comment-author">by Anthony Williams at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
<div class="comment"><div class="comment-content"><p>Anthony,</p>
<p>Thanks for very informative post.</p>
<p>I'm trying to understand details of your explanation in the "Double-checked locking returns" section
and interpolate it to a sort of Singleton application.
AFAIU, you suggest the double-checked locking should basically consists of the three elements: atomic read, lock guard and atomic load within the guarded scope. Is that correct?</p>
<p>Based on your get_data function, here is attempt to replicate equivalent of get_data() function above, but based on plain Win32 API:</p>
<p>expensive_data* get_single_data()
{
    static expensive_data* data;
    if (!::InterlockedCompareExchangePointer(reinterpret_cast&lt;LPVOID*&gt;(&amp;data), nullptr, nullptr))
    {
        std::lock_guard&lt;std::mutex&gt; lk(m); // Win32 API equivalent here
        if(!data)
        {
            expensive_data* tdata = new expensive_data();
            //tdata ... fill expensive data
            if (::InterlockedCompareExchangePointer(reinterpret_cast&lt;LPVOID*&gt;(&amp;data), tdata, nullptr))
                delete tdata;
        }
    }
    return data;
}</p>
<p>Would you consider it as correct and equivalent implementation of the double-checked locking variant explain above?
(Let's forget about the obvious RAII issue here.)</p>
<p>Mat</p></div><div class="comment-author">by Mateusz Loskot at <span class="comment-date">15:00:33 on Monday, 21 January 2019</span></div>
</div>
</div>
<div class="comment-form"><h4><a name="makecomment">Add your comment</a></h4><form method="POST" action="https://www.justsoftwaresolutions.co.uk/submit-comment.html"><input type="hidden" name="entry" value="/threading/multithreading-in-c++0x-part-6-double-checked-locking.html"><p class="entry-row"><span>Your name:</span><input type="text" name="name" value=""></p><p class="entry-row"><span>Email address:</span><input type="text" name="email" value=""></p><p>Your comment:</p><textarea name="info" cols="20" rows="10"></textarea><p><input type="submit" value="Submit Comment" name="send" class="submit-comment"></p></form></div>
<div class="clear"></div></div>
<div id="footbox">
  <p>
    Design and Content Copyright © 2005-2020 Just Software Solutions Ltd. All rights reserved. | <a href="https://www.justsoftwaresolutions.co.uk/privacy.html">Privacy Policy</a>
  </p>
</div>
</div></div></div><div id="widthfixer"></div></div><table cellspacing="0" cellpadding="0" class="gstl_50 gssb_c" style="width: 123px; display: none; top: 43px; left: 1180px; position: absolute;"><tbody><tr><td class="gssb_f"></td><td class="gssb_e" style="width: 100%;"></td></tr></tbody></table></body></html>