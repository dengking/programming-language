# open-std [P1144R2 Object relocation in terms of move plus destroy](http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p1144r2.html)

## Abstract

We define a new verb, "relocate," which is equivalent to a move and a destroy (analogous to the existing verb "swap," which is equivalent to a move, two move-assignments, and a destroy). For many C++ types, the "relocate" operation is implementable as a single `memcpy`. We provide a standard trait to detect types which are **trivially relocatable**, for the benefit of library writers. Finally, we provide a portable way for a user-defined type (e.g. `boost::shared_ptr`) to warrant(保证) to the implementation that it is trivially relocatable.



## 1. Introduction and motivation

### relocate

> NOTE: 
>
> 1、`memcpy`、`realloc`

C++17 knows the verbs "move," "copy," "destroy," and "swap," where "swap" is a higher-level operation composed of several lower-level operations. To this list we propose to add the verb "relocate," which is a higher-level operation composed of exactly two lower-level operations. Given an object type `T` and memory addresses `src` and `dst`, the phrase "***relocate*** a `T` from `src` to `dst`" means no more and no less than "*move-construct* `dst` from `src`, and then immediately *destroy* the object at `src`."



Just as the verb "swap" produces the adjective "swappable," the verb "relocate" produces the adjective "relocatable." Any type which is both move-constructible and destructible is ***relocatable***. The notion can be modified by adverbs: we say that a type is ***nothrow relocatable*** if its relocation operation is `noexcept`, and we say that a type is ***[trivially relocatable](http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p1144r2.html#abstract-opdef-trivially-relocatable)*** if its relocation operation is trivial (which, just like trivial move-construction and trivial copy-construction, means "the operation is tantamount(等同于) to a `memcpy`").



Almost all relocatable types are trivially relocatable: `std::unique_ptr<int>`, `std::vector<int>`, `std::string`. Non-trivially relocatable types exist but are rare; see [Appendix C: Examples of non-trivially relocatable class types](http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p1144r2.html#non-trivial-samples).

### 1.1. Optimizations enabled by trivial relocatability

#### 1.1.1. Vector resize

If we have a reliable way of detecting "trivial relocatability," we can optimize any routine that performs the moral equivalent of `realloc`, including

```c++
    std::vector<R>::resize
    std::vector<R>::reserve
    std::vector<R>::emplace_back
    std::vector<R>::push_back
```

[[Bench\]](http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p1144r2.html#biblio-bench) (presented at C++Now 2018) shows a 3x speedup on `std::vector<std::unique_ptr<int>>::resize`. [This Reddit thread](https://www.reddit.com/r/cpp/comments/9wj4vt/trivially_relocatable_in_san_diego_call_for/e9p76i4/) demonstrates a similar 3x speedup using the online tool Quick-Bench.

As observed in [[CppChat\]](http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p1144r2.html#biblio-cppchat) (@21:55): Just as with C++11 move semantics, you can write benchmarks to show whatever speedup you like. The more complicated your types' move-constructors and destructors, the more time you save by eliminating calls to them.

> NOTE: 
>
> 1、性能的提升源自于消除对"move-constructors and destructors"的调用，因此最终的实现，就相当于memory copy，实现上可以直接使用类似于`realloc`的操作，关于`realloc`，参见 cppreference [realloc](https://en.cppreference.com/w/c/memory/realloc)。
>
> 

#### 1.1.2. Swap

> NOTE: 
>
> 1、这段话没有理解

Given a reliable way of detecting **trivial relocatability**, we can optimize any routine that uses the moral equivalent of `std::swap`, such as

```c++
    std::swap
    std::sort
    std::vector<R>::insert (arguably)
```

#### 1.1.3. More efficient small-buffer type-erasure

Given a reliable way of detecting trivial relocatability, we can de-duplicate the code generated by small-buffer-optimized (SBO) type-erasing wrappers such as `std::function` and `std::any`. For these types, a *move* of the wrapper object is implemented in terms of a *relocation* of the contained object. (See for example [libc++'s std::any](http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p1144r2.html#biblio-libcxxany), where the function that performs the relocation operation is confusingly named `__move`.) In general, the *relocate* operation for a contained type `C` must be uniquely codegenned for each different `C`, leading to code bloat. But a single instantiation suffices to relocate every *trivially* relocatable `C` in the program. A smaller number of instantiations means faster compile times, a smaller text section, and "hotter" code (because a relatively higher proportion of your code now fits in icache).