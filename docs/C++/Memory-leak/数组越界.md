昨天我就碰到了数组越界导致的错误。让我比较好奇的是：
1. c++没有数组越界检查机制
2. 数组越界之后，居然能够访问到数据，虽然这些数据都是非法的。

这些是需要我进行研究的

关于数组越界，涉及到如下问题：
1. 使用char array来保存字符串，要使用如下写法：

```
p_arr=new char[strlen(str)+1]
```
+1是为了要给'\0'占个座，防止越界。
刚刚按照这个网址http://blog.csdn.net/sxhelijian/article/details/8928528/
上的事例用gdb调试了一下，并没有发现什么大的问题，有一个问题就是：
p 变量 和cout输出的内容不相同，如下

```
(gdb) r
Starting program: /home/dk/linux_and_c/cpp/array_out_of_bound/cin_array_2 
abcde
abcde

Breakpoint 1, main () at cin_array_2.cpp:8
8	    cout<<a<<endl;  
(gdb) p a
$3 = "abcd"
(gdb) p b
$4 = "abcd"
(gdb) c
Continuing.
abcde
abcde

Program exited normally.
```
显然这就是程序的异常所在，程序已经发生了越界。

#什么是越界访问？？
参见《内存溢出、内存泄露、内存越界、缓冲区溢出、栈溢出》

# 检查下标是否越界数组类
可以参考如下代码：

```
#include <iostream>
#include <string>
using namespace std;
class check
{
public:
    check(char*s)
    {
        str=new char[strlen(s)+1];
        strcpy(str,s);
        len=strlen(s);
    }
    char operator[](int n)
    {
        if(n>len-1)
        {
            cout<<"数组下标越界"<<endl;
            return ' ';
        }
        else
        {
            cout<<"数组下标没有越界"<<endl;
            return *(str+n);
        }
    }
    void Print(){cout<<str<<endl;}
private:
    char *str;
    int len;
};
 
void main()
{
    check array("GoodMorning");//类的构造函数
    array.Print();
    cout<<"Location 0:"<<array[0]<<endl;//判断下标为0是否越界
    cout<<"Location 20:"<<array[20]<<endl;//判断下标为20是否越界
}
```


