# Type traits for reference



## [cppreference std::add_lvalue_reference, std::add_rvalue_reference](https://en.cppreference.com/w/cpp/types/add_reference) 

Creates an lvalue or rvalue reference type of `T`.

The type referred by the nested type `type`

| Type trait |       **The type referred by the nested type** `type`        | **The type referred by the nested type** `type` |
| :--------: | :----------------------------------------------------------: | ----------------------------------------------- |
|            | `T` is a [referenceable type](https://en.cppreference.com/w/cpp/meta#Definitions) | `T` is not a referenceable type                 |
|    (1)     | `T&`[[1\]](https://en.cppreference.com/w/cpp/types/add_reference#cite_note-1) | `T`                                             |
|    (2)     | `T&&`[[2\]](https://en.cppreference.com/w/cpp/types/add_reference#cite_note-2) | `T`                                             |

If the program adds specializations for any of the templates described on this page, the behavior is undefined.

### Use case

The major difference to directly using `T&` or `T&&` is that `T` can be a non-[referenceable](https://en.cppreference.com/w/cpp/meta#Definitions) type. For example, `std::add_lvalue_reference<void>::type` is `void`, while `void&` leads to a compilation error.



### Possible implementation 



#### [cppreference SFINAE # SFINAE in partial specializations](https://en.cppreference.com/w/cpp/language/sfinae)

Deduction and substitution also occur while determining whether a specialization of a class or variable(since C++14) template is generated by some [partial specialization](https://en.cppreference.com/w/cpp/language/partial_specialization) or the primary template. A **substitution failure** is not treated as a hard-error during such determination, but makes the corresponding **partial specialization** declaration ignored instead, as if in the **overload resolution** involving function templates.

```c++
// primary template handles non-referenceable types:
template<class T, class = void>
struct reference_traits {
    using add_lref = T;
    using add_rref = T;
};

// specialization recognizes referenceable types:
template<class T>
struct reference_traits<T, std::void_t<T &>> {
    using add_lref = T &;
    using add_rref = T &&;
};

template<class T>
using add_lvalue_reference_t = typename reference_traits<T>::add_lref;

template<class T>
using add_rvalue_reference_t = typename reference_traits<T>::add_rref;

```

> NOTE:
>
> 对于referenceable  type，`std::void_t<T &>` 是能够替换成功的，但是对于non-referenceable type，`std::void_t<T &>` 无法替换成功，显然 `reference_traits` 是能够识别referenceable  type和non-referenceable type的。



#### [cppreference std::add_lvalue_reference, std::add_rvalue_reference](https://en.cppreference.com/w/cpp/types/add_reference) 

```c++
namespace detail {
    template<class T>
    struct type_identity {
        using type = T;
    }; // or use std::type_identity (since C++20)

    template<class T> // Note that “cv void&” is a substitution failure
    auto try_add_lvalue_reference(int) -> type_identity<T &>;
    template<class T> // Handle T = cv void case
    auto try_add_lvalue_reference(...) -> type_identity<T>;

    template<class T>
    auto try_add_rvalue_reference(int) -> type_identity<T &&>;
    template<class T>
    auto try_add_rvalue_reference(...) -> type_identity<T>;
} // namespace detail

template<class T>
struct add_lvalue_reference : decltype(detail::try_add_lvalue_reference<T>(0)) {};

template<class T>
struct add_rvalue_reference : decltype(detail::try_add_rvalue_reference<T>(0)) {};

```



其中使用到了一个特殊的技巧: **meta function**:

```c++
template<class T> // Note that “cv void&” is a substitution failure
auto try_add_lvalue_reference(int) -> type_identity<T &>;

template<class T> // Handle T = cv void case
auto try_add_lvalue_reference(...) -> type_identity<T>;
```

- The first function template `try_add_lvalue_reference` takes an `int` parameter and returns a `type_identity<T &>`, which represents the type `T &` (an lvalue reference to `T`).
- The second overload of `try_add_lvalue_reference` takes a variadic argument (`...`) and is a fallback that returns `type_identity<T>`. This overload is chosen when the first overload fails to instantiate, which happens if `T` is `void` or if the substitution fails for any other reason.

上述函数就是meta function，需要注意的是: 它们没有函数体，但是在后面还是调用了这个函数:

```c++
template<class T>
struct add_lvalue_reference : decltype(detail::try_add_lvalue_reference<T>(0)) {};
```



#### Helper types

```c++
template< class T >
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

template< class T >
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;
```



#### Example

```C++
#include <iostream>
#include <type_traits>

template<typename T>
void print_type() {
    if constexpr (std::is_same_v<T, int>) {
        std::cout << "int\n";
    } else if constexpr (std::is_same_v<T, int &>) {
        std::cout << "int&\n";
    } else if constexpr (std::is_same_v<T, int &&>) {
        std::cout << "int&&\n";
    } else {
        std::cout << "other type\n";
    }
}

int main() {
    print_type<std::add_lvalue_reference<int>::type>(); // Output: int&
    print_type<std::add_rvalue_reference<int>::type>(); // Output: int&&
    print_type<std::add_lvalue_reference<void>::type>(); // Output: other type
    print_type<std::add_rvalue_reference<void>::type>(); // Output: other type
    return 0;
}

```





## Type trait: `is_referenceable` 

### 写法1(错误):

```c++
#include <iostream>
#include <type_traits>

// Primary template for is_referenceable
template<typename T, typename = void>
struct is_referenceable : std::false_type {};

// Specialization for lvalue references
template<typename T>
struct is_referenceable<T, std::void_t<T &>> : std::true_type {};

// Specialization for rvalue references
template<typename T>
struct is_referenceable<T, std::void_t<T &&>> : std::true_type {};

// Helper variable template
template<typename T>
inline constexpr bool is_referenceable_v = is_referenceable<T>::value;

// Test function
template<typename T>
void test_referenceable() {
    std::cout << "Is referenceable: " << std::boolalpha << is_referenceable_v<T> << "\n";
}

int main() {
    test_referenceable<int>(); // Should be true
    test_referenceable<int &>(); // Should be true
    test_referenceable<int &&>(); // Should be true
    test_referenceable<void>(); // Should be false
    test_referenceable<void *>(); // Should be true
    test_referenceable<void (&)()>(); // Should be false (function type)
    test_referenceable<int (*)()>(); // Should be false (function pointer)
    test_referenceable<int[5]>(); // Should be false (array type)
    test_referenceable<int[]>(); // Should be false (incomplete type)

    return 0;
}

```

编译报错:

```c++
Struct is_referenceable<T, std::void_t<T &&>> has already been defined or declare
```

这种写法的问题是: compiler认为 `struct is_referenceable<T, std::void_t<T &>>`  和  `struct is_referenceable<T, std::void_t<T &&>>` 是相同类型。  



### 写法2(错误):

尝试加上reference

```c++
#include <iostream>
#include <type_traits>
namespace detail {
    template<class T>
    struct type_identity {
        using type = T;
    }; // or use std::type_identity (since C++20)

    template<class T> // Note that “cv void&” is a substitution failure
    auto try_add_lvalue_reference(int) -> type_identity<T &>;
    template<class T> // Handle T = cv void case
    auto try_add_lvalue_reference(...) -> type_identity<T>;

    template<class T>
    auto try_add_rvalue_reference(int) -> type_identity<T &&>;
    template<class T>
    auto try_add_rvalue_reference(...) -> type_identity<T>;
} // namespace detail

template<class T>
struct add_lvalue_reference : decltype(detail::try_add_lvalue_reference<T>(0)) {};

template<class T>
struct add_rvalue_reference : decltype(detail::try_add_rvalue_reference<T>(0)) {};


// Helper variable template
template<typename T>
inline constexpr bool is_l_referenceable_v = !std::is_same_v<add_lvalue_reference_t<T>, T>;

template<typename T>
inline constexpr bool is_r_referenceable_v = !std::is_same_v<add_rvalue_reference_t<T>, T>;


// Helper variable template
template<typename T>
inline constexpr bool is_referenceable_v = is_l_referenceable_v<T> || is_r_referenceable_v<T>;

// Test function
template<typename T>
void test_referenceable() {
    std::cout << "Is referenceable: " << std::boolalpha << is_referenceable_v<T> << "\n";
}

int main() {
    test_referenceable<int>(); // Should be true
    test_referenceable<int &>(); // Should be true
    test_referenceable<int &&>(); // Should be true
    test_referenceable<void>(); // Should be false
    test_referenceable<void *>(); // Should be true
    test_referenceable<void (&)()>(); // Should be false (function type)
    test_referenceable<int (*)()>(); // Should be false (function pointer)
    test_referenceable<int[5]>(); // Should be false (array type)
    test_referenceable<int[]>(); // Should be false (incomplete type)

    return 0;
}

```

输出如下:

```c++
Is referenceable: true
Is referenceable: false
Is referenceable: true
Is referenceable: false
Is referenceable: true
Is referenceable: false
Is referenceable: true
Is referenceable: true
Is referenceable: true
```

显然存在错误: `int &` 是 referenceable 的，但是上述程序将它判断为false了。

上述写法的错误在于: 它通过 `std::add_lvalue_reference_t` 来尝试为 `T` 添加reference，然后判断添加后的类型是否和原类型一致来判断是否是referenceable 的，这种方式的一个致命问题是: 对于 `int&`，它的lvalue reference也是  `int&`。

### 写法3: SFINAE





## [std::is_lvalue_reference](https://en.cppreference.com/w/cpp/types/is_lvalue_reference) 

```c++
#include <type_traits>
template<class T>
struct is_lvalue_reference : std::false_type {};
template<class T>
struct is_lvalue_reference<T &> : std::true_type {};

```



## [std::is_rvalue_reference](https://en.cppreference.com/w/cpp/types/is_rvalue_reference) 

```c++
#include <type_traits>

template<class T>
struct is_rvalue_reference : std::false_type {};
template<class T>
struct is_rvalue_reference<T &&> : std::true_type {};

```



## [std::is_reference](https://en.cppreference.com/w/cpp/types/is_reference) 

```c++
#include <type_traits>
template<class T>
struct is_reference : std::false_type {};
template<class T>
struct is_reference<T &> : std::true_type {};
template<class T>
struct is_reference<T &&> : std::true_type {};

```

