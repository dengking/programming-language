# medium [Implementing structs by value in Dart FFI](https://medium.com/dartlang/implementing-structs-by-value-in-dart-ffi-1cb1829d11a9)

In the [Dart 2.12](https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87) release, we extended our [C-interop feature, Dart FFI,](https://dart.dev/guides/libraries/c-interop) with the ability to [pass structs by value](https://github.com/dart-lang/sdk/issues/36730). This article talks about what it took to add this feature to the Dart SDK. If you’re interested in low-level language implementation details or in platform conventions for passing structs by value, keep reading.

> NOTE: 
>
> 一、 [pass structs by value](https://github.com/dart-lang/sdk/issues/36730) 所指向的是 GitHub [[ffi] Support passing and returning composites (structs) by value. #36730](https://github.com/dart-lang/sdk/issues/36730) 
>
> 



This article talks about both developing the API and figuring out the ABI (Application Binary Interface) for the struct-by-value feature. During the two years we worked on this feature (and other Dart FFI features), we discovered many constraints that required changing the API. The ABI journey was equally interesting, illustrating that you can take multiple approaches to nailing down the details of a hard problem.

> NOTE:
>
> 一、最后一段话的意思: 
>
> "ABI之旅也同样有趣，它说明了您可以采用多种方法来确定一个难题的细节。"

## Pass by value and pass by reference in C/C++



```C
struct Coord {
  double x;
  double y;
  Coord* next;
};

Coord TranslateByValue(Coord coord) {
  coord.x = coord.x + 10.0;
  coord.y = coord.y + 10.0;
  return coord;
}

void TranslateByPointer(Coord* coord) {
  coord->x = coord->x + 10.0;
  coord->y = coord->y + 10.0;
}
```



**Pass by value**

```C
Coord c1 = {10.0, 10.0, nullptr};
Coord c2 = TranslateByValue(c1);
```

**Pass by reference**

```C
Coord c1 = {10.0, 10.0, nullptr};
TranslateByPointer(&c1);
```



## The API design journey

> NOTE: 
>
> 这一段作者主要讲述的是 `dart:ffi` API的设计历程

The original Dart FFI [prototype](https://dart-review.googlesource.com/c/sdk/+/80124) already had support for passing pointers to structs. However, we redesigned the API multiple times to accommodate various use cases and constraints.

### Initial design

Our initial design enabled allocating structs in memory, passing those pointers to C, and modifying the fields of the structs. With that approach, the `Struct` class extended the `Pointer` class:

> NOTE: 
>
> 一、下面的实现方式其实是非常的C++的
>
> ```dart
>   static Coordinate allocate({int count: 1}) =>
>     allocate<Uint8>(count: count * sizeOf()).cast();
> ```
>
> 是否要考虑alignment？
>
> 



```dart
@struct
class Coordinate extends Pointer<Void> {
  @Double()
  double x;

  @Double()
  double y;

  @Pointer()
  Coordinate next;

  /// generated by @ffi.struct annotation
  external static int sizeOf();
	
  static Coordinate allocate({int count: 1}) =>
    allocate<Uint8>(count: count * sizeOf()).cast();
}
```



```dart
final c = Coordinate.allocate()
  ..x = 10.0
  ..y = 10.0;
```



However, two years ago we realized that [this design had an issue](https://github.com/dart-lang/sdk/issues/35840). By having the `Coordinate` extend `Pointer`, we could not distinguish between `Coordinate` and `Coordinate*`.

> NOTE: 
>
> 一、" [this design had an issue](https://github.com/dart-lang/sdk/issues/35840) "指向的是: github [Re-design struct API to facilitate reference semantics #35840](https://github.com/dart-lang/sdk/issues/35840) 
>
> 



### Distinguishing between Coordinate and Coordinate*

We [introduced](https://dart-review.googlesource.com/c/sdk/+/101291) `Struct` to Dart FFI and made structs extend this class:

```dart
abstract class Struct<S extends NativeType> extends NativeType {
  final Pointer<S> addressOf;
}
```

Now a `Pointer<Coordinate>` in Dart represents a `Coordinate*` in C, and a `Coordinate` in Dart represents a `Coordinate` in C.

This meant that the `next` field had the type `Pointer<Coordinate>`, which made the `@Pointer` annotation redundant. So, we [got rid of Pointer annotations](https://dart-review.googlesource.com/c/sdk/+/108415).



```dart
class Coordinate extends Struct<Coordinate> {
  @Double()
  double x;

  @Double()
  double y;

  Pointer<Coordinate> next;
}
```

Because we now represented pointers to structs as `Pointer` objects, we started using the `allocate` factory on `Pointer`:

```dart
final c = Pointer<Coordinate>.allocate();
```

> NOTE: 
>
> 在最新版的dart中，`Pointer` 已经没有 `allocate` 成员方法了，参见:
>
> dart [`Pointer<T extends NativeType> class`](https://api.dart.dev/stable/2.13.4/dart-ffi/Pointer-class.html) 
>
> 

To get access to the fields of a `Pointer<Coordinate>`, we need an object of type `Coordinate`, because that object has the fields `x`, `y`, and `next`. For this, we had the `load` method on `Pointer` already.

```dart
c.load<Coordinate>().x = 10.0;
```

### Extension methods to the rescue

Dart 2.7 [introduced](https://medium.com/dartlang/dart-2-7-a3710ec54e97) extension methods. With extension methods, we could [pattern match](https://dart-review.googlesource.com/c/sdk/+/118992/14/sdk/lib/ffi/ffi.dart) on the type argument `T` in `Pointer<T>`:

```dart
extension StructPointer<T extends Struct> on Pointer<T> {
  external T get ref;
}
```

Pattern matching on the type argument enabled us to [get rid of the verbosity](https://dart-review.googlesource.com/c/sdk/+/118993/16/tests/ffi/structs_test.dart) on call sites:

```dart
c.ref.y = 10.0; // ref is pattern matched to be of type Coordinate.
```



### Stop leaking backing storage

When returning a struct by value from C to Dart, we don’t want to `malloc` C memory to save the struct, because that would be slow *and* burden the user with freeing it. So, instead, the struct is copied to a `TypedData`, and the `Coordinate` can have either a `Pointer` or a `TypedData` as backing storage.

However, `addressOf`, which was introduced in the first redesign, had type `Pointer`. This type conveyed that it was always backed by C memory, but this was no longer true.

So, we [deprecated](https://github.com/dart-lang/sdk/issues/40667) `addressOf`.

> NOTE:
>
> 关于为什么`addressOf` 被  [deprecated](https://github.com/dart-lang/sdk/issues/40667) 了，没有理解

### For optimizations

The last step is to require invocations of various Dart FFI methods, including the ones related to structs, to have [compile-time constant type arguments](https://github.com/dart-lang/sdk/issues/44621):

```dart
extension StructPointer<T extends Struct> on Pointer<T> {
  /// Must invoke with a constant [T].
  external T get ref;
}
```

## The ABI discovery journey

> NOTE: 
>
> 未阅读
