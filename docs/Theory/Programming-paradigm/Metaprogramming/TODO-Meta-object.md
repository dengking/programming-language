# [Metaobject](https://en.wikipedia.org/wiki/Metaobject) 

In [computer science](https://en.wikipedia.org/wiki/Computer_science), a **metaobject** is an [object](https://en.wikipedia.org/wiki/Object_(computer_science)) that manipulates, creates, describes, or implements **objects** (including itself). The object that the metaobject pertains to(所属) is called the **base object**. Some information that a metaobject might define includes the base object's [type](https://en.wikipedia.org/wiki/Type_system), [interface](https://en.wikipedia.org/wiki/Interface_(computer_science)), [class](https://en.wikipedia.org/wiki/Class_(computer_science)), [methods](https://en.wikipedia.org/wiki/Method_(computer_science)), [attributes](https://en.wikipedia.org/wiki/Attribute_(computing)), [parse tree](https://en.wikipedia.org/wiki/Parse_tree), etc. Metaobjects are examples of the computer science concept of [reflection](https://en.wikipedia.org/wiki/Reflection_(computer_programming)), where a system has access (usually at **run time**) to its own internal structure. **Reflection** enables a system to essentially rewrite itself on the fly(在运行过程中rewrite自己), to alter its own implementation as it executes.[[1\]](https://en.wikipedia.org/wiki/Metaobject#cite_note-1)

### Metaobject protocol

A **metaobject protocol** (MOP) provides the vocabulary ([protocol](https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming))) to access and manipulate the **structure** and **behaviour** of systems of objects. Typical functions of a metaobject protocol include:[[2\]](https://en.wikipedia.org/wiki/Metaobject#cite_note-2)

- Create or delete a new class
- Create a new property or method
- Cause a class to inherit from a different class ("change the class structure")
- Generate or change the code defining the methods of a class

**Metaobject protocol** is contrary to the "closed" aspect of Bertrand Meyer's [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle), which holds that software object systems should be *open for extension* but *closed for modification*. **Metaobject protocol**, by contrast, transparently exposes the internal composition of objects and the entire **object system** in terms of the system itself(Metaobject协议根据系统本身透明地公开对象的内部组成和整个对象系统). A **metaobject protocol** is not merely an [interface](https://en.wikipedia.org/wiki/Application_Programming_Interface) to an "underlying" implementation; rather, through **metaobject protocol** the **object system** is [recursively implemented](https://en.wikipedia.org/wiki/Recursive_definition) in terms of a *meta*-object system(通过元对象协议，对象系统以元对象系统的形式递归地实现), which itself is theoretically implemented in terms of a *meta*-metaobject system(元对象系统本身在理论上是根据元对象系统实现的), and so on until an arbitrary [base case](https://en.wikipedia.org/wiki/Base_case_(recursion)) (a consistent [state](https://en.wikipedia.org/wiki/State_(computing)) of the object system) is determined, with the protocol as such being the **recursive functional relationship** between these implementation levels.

Implementing object systems in such a way opens the possibility for radical discretionary redesign(以这种方式实现对象系统开启了激进的自由裁量重新设计的可能性), providing deep flexibility but introducing possibly complex or difficult-to-understand **metastability issues**(亚稳态问题) (for instance, the object system must not [destructively update](https://en.wikipedia.org/wiki/Persistent_data_structure) its own metaobject protocol - its internal self-representation(对象系统不得破坏性地更新其自己的元对象协议 - 其内部自我 -表示) - but the potential destructiveness of some updates is non-trivial to predict and may be hard to reason about(但是某些更新的潜在破坏性是非常重要的预测，并且可能很难推理)), depending on the recursive depth to which the desired modifications are propagated.[[3\]](https://en.wikipedia.org/wiki/Metaobject#cite_note-AMOP_text-3) For this reason, metaobject protocol, when present in a language, is usually used sparingly and for specialised purposes such as software that transforms other software or itself in sophisticated ways, for example in **reverse engineering**(逆向工程).[[4\]](https://en.wikipedia.org/wiki/Metaobject#cite_note-4)

这段话对metaobject protocol进行了评价

### Runtime and compile time

When **compilation**(汇编) is not available at run-time there are additional complications for the implementation of **metaobject protocol**. For example, it is possible to change the type hierarchy with such a protocol but doing so may cause problems for code compiled with an alternative class model definition. Some environments have found innovative solutions for this, e.g., by handling metaobject issues at compile time. A good example of this is [OpenC++](https://en.wikipedia.org/w/index.php?title=OpenC%2B%2B_(software_tool)&action=edit&redlink=1).[[5\]](https://en.wikipedia.org/wiki/Metaobject#cite_note-5)

It is noteworthy that the [Semantic Web](https://en.wikipedia.org/wiki/Semantic_Web) object-oriented model is more dynamic than most **standard object systems**, and is consistent with **runtime metaobject protocols**. For example, in the Semantic Web model classes are expected to change their relations to each other and there is a special [inference engine](https://en.wikipedia.org/wiki/Inference_engine) known as a **classifier** that can validate and analyze evolving class models.[[6\]](https://en.wikipedia.org/wiki/Metaobject#cite_note-6)

